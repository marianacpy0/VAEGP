import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = "/mnt/data/your_image.jpeg"  # Replace with your image path
image = cv2.imread(image_path)
output = image.copy()

# Convert to grayscale and apply a slight Gaussian blur to smooth edges
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(gray, (5, 5), 1)

# Apply adaptive thresholding to get binary image
thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                               cv2.THRESH_BINARY_INV, 11, 3)

# Detect contours in the binary image
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Loop through contours and filter based on circularity
circle_candidates = []
for contour in contours:
    # Fit an enclosing circle to get the radius
    ((x, y), radius) = cv2.minEnclosingCircle(contour)
    area = cv2.contourArea(contour)
    
    if radius > 5 and radius < 20:  # Radius range (adjust as needed)
        # Check circularity
        circularity = 4 * np.pi * (area / (cv2.arcLength(contour, True) ** 2))
        if 0.7 < circularity < 1.2:  # Circularity threshold for approximate circles
            circle_candidates.append((int(x), int(y), int(radius)))

# Draw the detected circles
for (x, y, r) in circle_candidates:
    cv2.circle(output, (x, y), r, (0, 255, 0), 2)  # Green boundary
    cv2.circle(output, (x, y), 2, (0, 0, 255), 3)  # Red center

# Show the result
plt.figure(figsize=(10, 10))
plt.imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB))
plt.title("Detected Circle Candidates")
plt.axis("off")
plt.show()