import cv2
import numpy as np
import matplotlib.pyplot as plt
import math

def show_image(title, image, cmap=None):
    plt.figure(figsize=(10, 10))
    plt.imshow(image, cmap=cmap)
    plt.title(title)
    plt.axis("off")
    plt.show()

def draw_circles_and_line(image, circles, title):
    """Draw circles and a line between the outer edges of the first and last circle in the trio."""
    output = image.copy()
    if len(circles) >= 3:
        # Sort circles by x-coordinate to ensure a consistent order
        circles = sorted(circles, key=lambda c: c[0])

        # Draw each detected circle
        for (x, y, r) in circles:
            cv2.circle(output, (x, y), r, (0, 255, 0), 2)  # Green circle boundary
            cv2.circle(output, (x, y), 2, (0, 0, 255), 3)  # Red center

        # Draw a line between the edges of the first and third circles in the trio
        x1, y1, r1 = circles[0]
        x3, y3, r3 = circles[2]
        cv2.line(output, (x1 - r1, y1), (x3 + r3, y3), (255, 0, 0), 2)  # Blue line showing the distance

    # Show the result with detected circles and the line
    show_image(title, cv2.cvtColor(output, cv2.COLOR_BGR2RGB))

def find_circles_hough(image):
    """Detect circles using the Hough Circle Transform."""
    # Convert to grayscale and apply Gaussian blur
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    show_image("Grayscale Image (Hough Circles)", gray, cmap='gray')
    show_image("Blurred Image (Hough Circles)", blurred, cmap='gray')
    
    # Use Hough Circle Transform to detect circles
    circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, dp=1.2, minDist=30, 
                               param1=50, param2=30, minRadius=5, maxRadius=50)
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        if len(circles) > 3:
            circles = sorted(circles, key=lambda c: c[2], reverse=True)[:3]
    else:
        circles = []
    
    return circles

def find_circles_contours(image):
    """Detect circles using contour-based approach."""
    # Convert to grayscale and apply Gaussian blur
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (3, 3), 1)
    show_image("Grayscale Image (Contours)", gray, cmap='gray')
    show_image("Blurred Image (Contours)", blurred, cmap='gray')
    
    # Apply adaptive thresholding and show result
    thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                   cv2.THRESH_BINARY_INV, 11, 2)
    show_image("Thresholded Image (Contours)", thresh, cmap='gray')
    
    # Detect contours
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Filter contours based on circularity and radius
    circle_candidates = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        if radius > 0:
            circularity = 4 * np.pi * (area / (cv2.arcLength(contour, True) ** 2))
            if 0.7 < circularity < 1.3 and 5 < radius < 50:  # Adjust as needed
                circle_candidates.append((int(x), int(y), int(radius)))
    
    # Sort by radius and select top three if more than three are detected
    if len(circle_candidates) > 3:
        circle_candidates = sorted(circle_candidates, key=lambda c: -c[2])[:3]
    
    return circle_candidates

# Load your image
image_path = "/path/to/your/image.jpg"
image = cv2.imread(image_path)

# Detect circles using Hough Circles
hough_circles = find_circles_hough(image)
draw_circles_and_line(image, hough_circles, "Detected Circles (Hough Transform)")

# Detect circles using Contours
contour_circles = find_circles_contours(image)
draw_circles_and_line(image, contour_circles, "Detected Circles (Contours)")