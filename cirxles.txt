import cv2
import numpy as np
import matplotlib.pyplot as plt
import math

def show_image(title, image, cmap=None):
    plt.figure(figsize=(10, 10))
    plt.imshow(image, cmap=cmap)
    plt.title(title)
    plt.axis("off")
    plt.show()

def filter_and_select_circles(circles, max_y_diff=10):
    """Filter circles to get the closest aligned set of three."""
    circles = sorted(circles, key=lambda c: (c[1], c[0]))
    filtered_circles = []
    for i in range(len(circles) - 2):
        y_diff1 = abs(circles[i][1] - circles[i+1][1])
        y_diff2 = abs(circles[i+1][1] - circles[i+2][1])
        if y_diff1 < max_y_diff and y_diff2 < max_y_diff:
            filtered_circles = circles[i:i+3]
            break
    return filtered_circles

def draw_circles_and_line(image, circles, title):
    """Draw circles and a line between the outer edges of the first and last circle in the trio."""
    output = image.copy()
    if len(circles) == 3:
        circles = sorted(circles, key=lambda c: c[0])
        for (x, y, r) in circles:
            cv2.circle(output, (x, y), r, (0, 255, 0), 2)
            cv2.circle(output, (x, y), 2, (0, 0, 255), 3)

        x1, y1, r1 = circles[0]
        x3, y3, r3 = circles[2]
        cv2.line(output, (x1 - r1, y1), (x3 + r3, y3), (255, 0, 0), 2)  # Blue line showing the distance
    show_image(title, cv2.cvtColor(output, cv2.COLOR_BGR2RGB))

def find_circles_contours(image):
    """Detect circles using contour-based approach."""
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (3, 3), 1)
    show_image("Grayscale Image (Contours)", gray, cmap='gray')
    show_image("Blurred Image (Contours)", blurred, cmap='gray')
    
    thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                   cv2.THRESH_BINARY_INV, 11, 2)
    show_image("Thresholded Image (Contours)", thresh, cmap='gray')
    
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    circle_candidates = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter == 0:
            continue
        circularity = 4 * np.pi * (area / (perimeter ** 2))
        if 0.7 < circularity < 1.3 and 5 < radius < 50:
            circle_candidates.append((int(x), int(y), int(radius)))
    
    filtered_circles = filter_and_select_circles(circle_candidates)
    return filtered_circles

# Conversion and Measurement
def calculate_conversion_factor(known_mm_distance, point1, point2):
    """Calculate conversion factor from pixels to mm."""
    pixel_distance = np.sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2)
    return known_mm_distance / pixel_distance

def measure_bounding_box_mm(bbox, conversion_factor):
    """Convert bounding box dimensions from pixels to mm."""
    width_pixels = bbox[2]
    height_pixels = bbox[3]
    width_mm = width_pixels * conversion_factor
    height_mm = height_pixels * conversion_factor
    return width_mm, height_mm

def detect_bounding_box(image):
    """Detect the largest bounding box around the object of interest."""
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    largest_contour = max(contours, key=cv2.contourArea)
    bbox = cv2.boundingRect(largest_contour)
    return bbox

# Load your image
image_path = "/path/to/your/image.jpg"  # Replace with actual path
image = cv2.imread(image_path)

# Step 1: Detect circles
contour_circles = find_circles_contours(image)
draw_circles_and_line(image, contour_circles, "Detected Circles (Contours)")

# Step 2: Calculate the pixel-to-mm conversion factor if we have three circles
if len(contour_circles) == 3:
    point1, point2 = (contour_circles[0][0], contour_circles[0][1]), (contour_circles[2][0], contour_circles[2][1])
    known_mm_distance = 10.0  # Known distance in mm between the first and third circle
    conversion_factor = calculate_conversion_factor(known_mm_distance, point1, point2)
    print(f"Conversion factor: {conversion_factor:.4f} mm per pixel")

    # Step 3: Detect and measure the bounding box in mm
    bbox = detect_bounding_box(image)
    width_mm, height_mm = measure_bounding_box_mm(bbox, conversion_factor)
    print(f"Bounding box dimensions: {width_mm:.2f} mm x {height_mm:.2f} mm")

    # Draw the bounding box on the image
    x, y, w, h = bbox
    output_image = image.copy()
    cv2.rectangle(output_image, (x, y), (x + w, y + h), (0, 0, 255), 2)  # Red bounding box
    show_image("Bounding Box with Measured Dimensions", cv2.cvtColor(output_image, cv2.COLOR_BGR2RGB))
else:
    print("Less than 3 circles found; unable to calculate distance.")




import cv2
import numpy as np
import matplotlib.pyplot as plt
import math

def show_image(title, image, cmap=None):
    plt.figure(figsize=(10, 10))
    plt.imshow(image, cmap=cmap)
    plt.title(title)
    plt.axis("off")
    plt.show()

def draw_circles_and_line(image, circles, title):
    """Draw circles and a line between the outer edges of the first and last circle in the trio."""
    output = image.copy()
    if len(circles) >= 3:
        # Sort circles by x-coordinate to ensure a consistent order
        circles = sorted(circles, key=lambda c: c[0])

        # Draw each detected circle
        for (x, y, r) in circles:
            cv2.circle(output, (x, y), r, (0, 255, 0), 2)  # Green circle boundary
            cv2.circle(output, (x, y), 2, (0, 0, 255), 3)  # Red center

        # Draw a line between the edges of the first and third circles in the trio
        x1, y1, r1 = circles[0]
        x3, y3, r3 = circles[2]
        cv2.line(output, (x1 - r1, y1), (x3 + r3, y3), (255, 0, 0), 2)  # Blue line showing the distance

    # Show the result with detected circles and the line
    show_image(title, cv2.cvtColor(output, cv2.COLOR_BGR2RGB))

def find_circles_hough(image):
    """Detect circles using the Hough Circle Transform."""
    # Convert to grayscale and apply Gaussian blur
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    show_image("Grayscale Image (Hough Circles)", gray, cmap='gray')
    show_image("Blurred Image (Hough Circles)", blurred, cmap='gray')
    
    # Use Hough Circle Transform to detect circles
    circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, dp=1.2, minDist=30, 
                               param1=50, param2=30, minRadius=5, maxRadius=50)
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        if len(circles) > 3:
            circles = sorted(circles, key=lambda c: c[2], reverse=True)[:3]
    else:
        circles = []
    
    return circles

def find_circles_contours(image):
    """Detect circles using contour-based approach."""
    # Convert to grayscale and apply Gaussian blur
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (3, 3), 1)
    show_image("Grayscale Image (Contours)", gray, cmap='gray')
    show_image("Blurred Image (Contours)", blurred, cmap='gray')
    
    # Apply adaptive thresholding and show result
    thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                   cv2.THRESH_BINARY_INV, 11, 2)
    show_image("Thresholded Image (Contours)", thresh, cmap='gray')
    
    # Detect contours
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Filter contours based on circularity and radius
    circle_candidates = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        if radius > 0:
            circularity = 4 * np.pi * (area / (cv2.arcLength(contour, True) ** 2))
            if 0.7 < circularity < 1.3 and 5 < radius < 50:  # Adjust as needed
                circle_candidates.append((int(x), int(y), int(radius)))
    
    # Sort by radius and select top three if more than three are detected
    if len(circle_candidates) > 3:
        circle_candidates = sorted(circle_candidates, key=lambda c: -c[2])[:3]
    
    return circle_candidates

# Load your image
image_path = "/path/to/your/image.jpg"
image = cv2.imread(image_path)

# Detect circles using Hough Circles
hough_circles = find_circles_hough(image)
draw_circles_and_line(image, hough_circles, "Detected Circles (Hough Transform)")

# Detect circles using Contours
contour_circles = find_circles_contours(image)
draw_circles_and_line(image, contour_circles, "Detected Circles (Contours)")