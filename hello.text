import pandas as pd
import plotly.express as px

# --- Step 1: Add a "type" column to each dataset ---
# Example: two datasets lube_A and lube_B with the same structure
lube_A["type"] = "Lubricant A"
lube_B["type"] = "Lubricant B"

# --- Step 2: Merge the two datasets into a single DataFrame ---
lube = pd.concat([lube_A, lube_B], ignore_index=True)

# --- Step 3: Count distribution of WATER (grouped by type) ---
water_counts = lube.groupby(["water_ppm", "type"]).size().reset_index(name="count")

fig_water = px.bar(
    water_counts,
    x="water_ppm",
    y="count",
    color="type",
    barmode="group",
    text="count",
    title="Data distribution by Water concentration (ppm)",
)
fig_water.update_traces(textposition="outside")
fig_water.update_layout(
    xaxis_title="Water (ppm)",
    yaxis_title="Number of samples"
)
fig_water.show()

# --- Step 4: Count distribution of AGE (grouped by type) ---
age_counts = lube.groupby(["age_hours", "type"]).size().reset_index(name="count")

fig_age = px.bar(
    age_counts,
    x="age_hours",
    y="count",
    color="type",
    barmode="group",
    text="count",
    title="Data distribution by Age (hours)",
)
fig_age.update_traces(textposition="outside")
fig_age.update_layout(
    xaxis_title="Age (hours)",
    yaxis_title="Number of samples"
)
fig_age.show()





import plotly.express as px

# Conteo de muestras por nivel de WATER
fig_water = px.histogram(
    lube,
    x="water_ppm",
    color="lubricant",  # opcional: si quieres ver qué lubricante aporta a cada nivel
    barmode="group",    # puedes cambiar a "stack" si quieres barras apiladas
    title="Distribución de datos por nivel de Water (ppm)"
)
fig_water.update_layout(xaxis_title="Water (ppm)", yaxis_title="Número de muestras")
fig_water.show()

# Conteo de muestras por nivel de AGE
fig_age = px.histogram(
    lube,
    x="age_hours",
    color="lubricant",  # opcional
    barmode="group",
    title="Distribución de datos por nivel de Age (hours)"
)
fig_age.update_layout(xaxis_title="Age (hours)", yaxis_title="Número de muestras")
fig_age.show()




import pandas as pd
import plotly.express as px

# --- Configura estas dos cosas según tu data ---
df = df_predictions_evaluation_.copy()   # o el DataFrame que estés usando
y_col = "TAN"                            # usa "TAN_pred" si quieres las predicciones

# Si tus age_hours son numéricos y quieres colores fijos:
df["age_hours"] = df["age_hours"].astype(int)

# Mapa de colores por age_hours (ajusta si tienes otros niveles)
discrete_map = {
    360: "blue",
    240: "red",
    120: "green"
}

# Orden de categorías en la leyenda
category_order = dict(age_hours=[360, 240, 120])

fig = px.scatter(
    df,
    x="water_ppm",
    y=y_col,
    color="age_hours",
    color_discrete_map=discrete_map,
    category_orders=category_order,
    hover_data=["water_ppm", "age_hours", y_col],
    title="TAN against water concentration and age hours"
)

# Opcional: tamaño de marcador y opacidad
fig.update_traces(marker=dict(size=10, line=dict(width=0)), opacity=0.9)

# Ejes y layout
fig.update_layout(
    xaxis_title="water_ppm",
    yaxis_title=y_col,
    template="plotly_white",
    width=900,
    height=500,
    legend_title_text="age_hours"
)

fig.show()







# --- Imports ---
import umap
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# -------------------------------------------------------------------
# Assumes you have:
# - latent_df: DataFrame con columnas 'Dim1', 'Dim2', ..., 'DimK' (tu espacio latente)
# - columnas auxiliares: 'TAN', 'age_hours', 'water_ppm', 'type', 'sweep_new' (si las usas en hover)
# - latent_dim: número de dims del espacio latente
# -------------------------------------------------------------------

# 1) Matriz latente
latent_matrix = latent_df[[f'Dim{i+1}' for i in range(latent_dim)]].values

# 2) UMAP (ajusta n_neighbors y min_dist si quieres más/menos patrón)
reducer = umap.UMAP(
    n_components=2,
    random_state=42,
    n_neighbors=30,   # prueba 10, 15, 30, 50
    min_dist=0.05     # prueba 0.0, 0.05, 0.1
)
embedding = reducer.fit_transform(latent_matrix)

# 3) Data para el plot
plot_df = latent_df.copy()
plot_df['UMAP_1'] = embedding[:, 0]
plot_df['UMAP_2'] = embedding[:, 1]

# 4) Figura base: scatter coloreado por TAN
fig = px.scatter(
    plot_df,
    x='UMAP_1',
    y='UMAP_2',
    color='TAN',
    color_continuous_scale='viridis',
    hover_data=['sweep_new', 'age_hours', 'water_ppm', 'type']  # quita/añade lo que gustes
)

# 5) “Camino temporal”: conecta puntos en orden de age_hours
path_df = plot_df.sort_values('age_hours')
fig.add_trace(
    go.Scatter(
        x=path_df['UMAP_1'],
        y=path_df['UMAP_2'],
        mode='lines',
        line=dict(width=1, color='rgba(60,60,60,0.35)'),
        name='Temporal path',
        showlegend=False
    )
)

# 6) Contornos de densidad para resaltar nubes/patrones
fig.add_trace(
    go.Histogram2dContour(
        x=plot_df['UMAP_1'],
        y=plot_df['UMAP_2'],
        colorscale='Greys',
        showscale=False,
        contours=dict(showlines=False),
        opacity=0.18,
        name='density'
    )
)

# 7) Layout limpio
fig.update_layout(
    title='UMAP Projection colored by TAN (with temporal path & density)',
    template='plotly_white',
    width=900,
    height=650,
    coloraxis_colorbar=dict(title='TAN')
)

# Relación de aspecto opcional (1:1) para no distorsionar
fig.update_yaxes(scaleanchor="x", scaleratio=1)

fig.show()








import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Guardar resultados en una lista
results = []

for i in range(1, latent_dim+1):
    dim = f"Dimension {i}"
    subset = melted_df[melted_df['Dimension'] == dim]
    corr_tan = subset['Latent Value'].corr(subset['TAN'])
    corr_water = subset['Latent Value'].corr(subset['water_ppm'])
    corr_age = subset['Latent Value'].corr(subset['age_hours'])
    
    results.append([dim, corr_tan, corr_water, corr_age])

# Convertir a DataFrame en formato correcto
corr_df = pd.DataFrame(results, columns=['Dimension', 'TAN', 'Water', 'Age'])
corr_df.set_index('Dimension', inplace=True)

# Revisar la forma
print(corr_df.head())
print(corr_df.shape)  # debería ser (#dimensiones, 3)

# Plot del heatmap
plt.figure(figsize=(8, 5))
sns.heatmap(corr_df, annot=True, cmap="coolwarm", center=0, fmt=".2f")
plt.title("Correlation of Latent Dimensions with TAN, Water, and Age", fontsize=14)
plt.tight_layout()
plt.show()







import numpy as np
import matplotlib.pyplot as plt

# Orden/df base
df_plot_ = df_predictions_evaluation_.reset_index(drop=True)

# ---- Figure con 2 columnas: 1) plot principal, 2) colorbar ----
fig = plt.figure(figsize=(12, 6), constrained_layout=True)
gs = fig.add_gridspec(nrows=1, ncols=2, width_ratios=[40, 1])  # ajusta el 40:1 si quieres más/menos espacio

ax1 = fig.add_subplot(gs[0, 0])   # eje principal (Y1)
ax2 = ax1.twinx()                  # eje secundario (Y2)
cax = fig.add_subplot(gs[0, 1])    # eje exclusivo para la colorbar

# Eje X (elige uno)
x = np.arange(len(df_plot_))       # opción 1: índice
# x = df_plot_['water_ppm']        # opción 2: usar Water en X

# ---- Y1: Age ----
ax1.plot(x, df_plot_['age_hours'], color='skyblue', linewidth=2, label='Age [hours]')
ax1.set_xlabel('Index / Sample' if isinstance(x, np.ndarray) else 'Water [ppm]')
ax1.set_ylabel('Age Hours', color='skyblue')
ax1.tick_params(axis='y', labelcolor='skyblue')

# ---- Y2: TAN_pred (línea) ----
ax2.plot(x, df_plot_['TAN_pred'], color='crimson', linewidth=2, label='TAN_pred')
ax2.set_ylabel('Predicted TAN', color='crimson')
ax2.tick_params(axis='y', labelcolor='crimson')

# ---- Scatter sobre la línea roja coloreado por Water ----
sc = ax2.scatter(x, df_plot_['TAN_pred'],
                 c=df_plot_['water_ppm'], cmap='viridis',
                 s=40, alpha=0.9, edgecolors='none')

# ---- Colorbar en el eje cax (fuera del plot) ----
cbar = fig.colorbar(sc, cax=cax, orientation='vertical')
cbar.set_label('Water [ppm]')

ax1.grid(True)
fig.suptitle('Age vs Predicted TAN con Water al lado', fontsize=14)
plt.show()





import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

df_plot_ = df_predictions_evaluation_.reset_index(drop=True)

fig, ax1 = plt.subplots(figsize=(10, 6))

# Age_hours en eje Y1
ax1.set_xlabel('Index / Sample')
ax1.set_ylabel('Age Hours', color='skyblue')
ax1.plot(df_plot_['age_hours'], color='skyblue', linewidth=2)
ax1.tick_params(axis='y', labelcolor='skyblue')

# Predicted TAN en eje Y2
ax2 = ax1.twinx()
ax2.set_ylabel('Predicted TAN', color='crimson')
ax2.plot(df_plot_['TAN_pred'], color='crimson', linewidth=2)
ax2.tick_params(axis='y', labelcolor='crimson')

# Scatter coloreado por water_ppm
sc = ax2.scatter(range(len(df_plot_)), df_plot_['TAN_pred'],
                 c=df_plot_['water_ppm'], cmap='viridis',
                 s=40, alpha=0.9, edgecolors='none')

# Crear un eje aparte abajo para la colorbar
divider = make_axes_locatable(ax1)
cax = divider.append_axes("bottom", size="5%", pad=0.6)
cbar = fig.colorbar(sc, cax=cax, orientation='horizontal')
cbar.set_label('Water [ppm]')

plt.title('Age vs Predicted TAN con Water como referencia', fontsize=14)
plt.grid(True)
plt.show()



import matplotlib.pyplot as plt

df_plot_ = df_predictions_evaluation_.reset_index(drop=True)

fig, ax1 = plt.subplots(figsize=(10, 6))

# Age_hours en eje Y1
ax1.set_xlabel('Index / Sample')
ax1.set_ylabel('Age Hours', color='skyblue')
ax1.plot(df_plot_['age_hours'], color='skyblue', linewidth=2)
ax1.tick_params(axis='y', labelcolor='skyblue')

# Predicted TAN en eje Y2
ax2 = ax1.twinx()
ax2.set_ylabel('Predicted TAN', color='crimson')
ax2.plot(df_plot_['TAN_pred'], color='crimson', linewidth=2)
ax2.tick_params(axis='y', labelcolor='crimson')

# Scatter coloreado por water_ppm
sc = ax2.scatter(range(len(df_plot_)), df_plot_['TAN_pred'],
                 c=df_plot_['water_ppm'], cmap='viridis',
                 s=40, alpha=0.9, edgecolors='none')

# Colorbar horizontal abajo
cbar = fig.colorbar(sc, ax=[ax1, ax2], orientation='horizontal', pad=0.2, shrink=0.8)
cbar.set_label('Water [ppm]')

plt.title('Age vs Predicted TAN con Water como referencia', fontsize=14)
fig.tight_layout()
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

df_plot_ = df_predictions_evaluation_.reset_index(drop=True)

fig, ax1 = plt.subplots(figsize=(10, 6))

# Age_hours en eje Y1
ax1.set_xlabel('Index / Sample')
ax1.set_ylabel('Age Hours', color='skyblue')
ax1.plot(df_plot_['age_hours'], color='skyblue', linewidth=2)
ax1.tick_params(axis='y', labelcolor='skyblue')

# Predicted TAN en eje Y2
ax2 = ax1.twinx()
ax2.set_ylabel('Predicted TAN', color='crimson')
ax2.plot(df_plot_['TAN_pred'], color='crimson', linewidth=2)
ax2.tick_params(axis='y', labelcolor='crimson')

# Scatter coloreado por water_ppm
sc = ax2.scatter(range(len(df_plot_)), df_plot_['TAN_pred'],
                 c=df_plot_['water_ppm'], cmap='viridis',
                 s=40, alpha=0.9, edgecolors='none')

# Crear un eje aparte a la izquierda para la colorbar
divider = make_axes_locatable(ax1)
cax = divider.append_axes("left", size="3%", pad=0.8)
cbar = fig.colorbar(sc, cax=cax, orientation='vertical')
cbar.set_label('Water [ppm]')

plt.title('Age vs Predicted TAN con colorbar a la izquierda', fontsize=14)
fig.tight_layout()
plt.show()



import matplotlib.pyplot as plt

# Ordenamos si quieres un visual más suave
df_plot_ = df_predictions_evaluation_.sort_values(by='water_ppm').reset_index(drop=True)

fig, ax1 = plt.subplots(figsize=(10, 6))

# 💧 EJE Y1: Age Hours (izquierdo)
color_age = 'skyblue'
ax1.set_xlabel('Water [ppm]')
ax1.set_ylabel('Age Hours', color=color_age)
ax1.plot(df_plot_['water_ppm'], df_plot_['age_hours'], color=color_age, linewidth=2, label='Age [hours]')
ax1.tick_params(axis='y', labelcolor=color_age)

# 🔥 EJE Y2: Predicted TAN (derecho)
ax2 = ax1.twinx()
color_tan = 'crimson'
ax2.set_ylabel('Predicted TAN', color=color_tan)
ax2.plot(df_plot_['water_ppm'], df_plot_['TAN_pred'], color=color_tan, linewidth=2, label='TAN_pred')
ax2.tick_params(axis='y', labelcolor=color_tan)

# ✨ Scatter en parte baja para mostrar la distribución de `water_ppm` discretamente
ax1.scatter(
    df_plot_['water_ppm'],          # eje X
    [0] * len(df_plot_),            # eje Y en cero (o muy cerca)
    color='gray',
    alpha=0.3,
    marker='|',
    s=40,
    label='Water markers'
)

# 💅 Título y visual
plt.title('Age and Predicted TAN vs Water ppm (con marcadores de agua)', fontsize=14)
fig.tight_layout()
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Ordenar por water si quieres más suavecito visual
df_plot = df_predictions_evaluation_.sort_values(by='water_ppm').reset_index(drop=True)

fig, ax1 = plt.subplots(figsize=(10, 6))

# Primer eje: WATER
ax1.set_xlabel('Observación (ordenada por agua)')
ax1.set_ylabel('Water [ppm]', color='skyblue')
ax1.plot(df_plot['water_ppm'], color='skyblue', linewidth=2, label='Water [ppm]')
ax1.tick_params(axis='y', labelcolor='skyblue')

# Segundo eje: TAN_pred
ax2 = ax1.twinx()
ax2.set_ylabel('Predicted TAN', color='crimson')
ax2.plot(df_plot['TAN_pred'], color='crimson', linewidth=2, label='TAN_pred')
ax2.tick_params(axis='y', labelcolor='crimson')

# Título y visual
plt.title('Comparación de Water vs TAN Predicho (doble eje)', fontsize=14)
fig.tight_layout()
plt.grid(True)
plt.show()