import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = "/mnt/data/80061306-7492-4430-BC6A-C4DDB125B71F.jpeg"
image = cv2.imread(image_path)
height, width = image.shape[:2]

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Adjust adaptive threshold parameters
adaptive_thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                        cv2.THRESH_BINARY_INV, 35, 15)

# Display the adaptive threshold result
plt.imshow(adaptive_thresh, cmap='gray')
plt.title("Adjusted Adaptive Threshold Result")
plt.show()

# Apply a larger morphological closing to fill gaps in the main contour
kernel = np.ones((15, 15), np.uint8)
morph = cv2.morphologyEx(adaptive_thresh, cv2.MORPH_CLOSE, kernel)

# Display the result after morphological closing
plt.imshow(morph, cmap='gray')
plt.title("Morphological Closing Result")
plt.show()

# Detect contours in the thresholded and closed image
contours, _ = cv2.findContours(morph, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Identify the largest contour, which is assumed to be the main black structure
largest_contour = max(contours, key=cv2.contourArea)
x, y, w, h = cv2.boundingRect(largest_contour)

# Draw the bounding box of the largest contour for visualization on a copy of the original image
contour_image = image.copy()
cv2.rectangle(contour_image, (x, y), (x + w, y + h), (0, 255, 0), 2)
cv2.putText(contour_image, "Main Black Contour", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

# Display the image with the bounding box
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title("Original Image with Bounding Box of Largest Contour")
plt.show()

# Use Canny edge detection with adjusted thresholds
roi_edges = cv2.Canny(morph[y:y+h, x:x+w], 30, 100)

# Display the Canny edge result within the ROI
plt.imshow(roi_edges, cmap='gray')
plt.title("Adjusted Canny Edge Detection on ROI")
plt.show()

# Detect lines within the bounding box region using Hough Line Transform
lines = cv2.HoughLinesP(roi_edges, 1, np.pi / 180, threshold=50, minLineLength=100, maxLineGap=20)

# Initialize variables to store reference lines
top_red_line = None
blue_vertical_line = None
purple_vertical_line = None

# Define regions based on this bounding box
top_region_y = y + h * 0.1  # Upper 10% of the contour bounding box as "top" region
bottom_region_y = y + h * 0.9  # Lower 10% of the contour bounding box as "bottom" region
left_region_x = x + w * 0.1  # Left side of the contour bounding box
right_region_x = x + w * 0.9  # Right side of the contour bounding box

# Classify lines based on their length and position within the bounding box
if lines is not None:
    for line in lines:
        x1, y1, x2, y2 = line[0]
        
        # Adjust line coordinates to the full image context
        x1, y1, x2, y2 = x + x1, y + y1, x + x2, y + y2
        line_length = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        midpoint_x, midpoint_y = (x1 + x2) / 2, (y1 + y2) / 2

        # Classify based on contour-relative regions
        if top_red_line is None and midpoint_y < top_region_y and line_length > width / 4:
            top_red_line = line[0]
            cv2.line(contour_image, (x1, y1), (x2, y2), (0, 0, 255), 2)
            cv2.putText(contour_image, "Top Red Line", (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
        
        elif blue_vertical_line is None and midpoint_x < left_region_x and line_length > height / 8:
            blue_vertical_line = line[0]
            cv2.line(contour_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
            cv2.putText(contour_image, "Blue Line", (x1 + 10, y1), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)

        elif purple_vertical_line is None and midpoint_x > right_region_x and line_length > height / 8:
            purple_vertical_line = line[0]
            cv2.line(contour_image, (x1, y1), (x2, y2), (255, 0, 255), 2)
            cv2.putText(contour_image, "Purple Line", (x1 + 10, y1), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 255), 2)

# Display the final result with detected lines and labeled regions
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title("Detected Reference Lines with Adjustments")
plt.show()