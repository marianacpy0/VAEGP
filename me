import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = "/mnt/data/36EEA805-E52C-4D35-8930-472331FEAFF3.jpeg"  # Update if needed
image = cv2.imread(image_path)
height, width = image.shape[:2]

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Canny edge detection
edges = cv2.Canny(gray, 50, 150)

# Apply morphological closing to connect components
kernel = np.ones((15, 15), np.uint8)
closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)

# Find contours from the closed edge-detected image
contours, _ = cv2.findContours(closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Filter contours to keep the largest one that is close to the image edges
largest_contour = None
max_area = 0
for cnt in contours:
    area = cv2.contourArea(cnt)
    x, y, w, h = cv2.boundingRect(cnt)

    # Check if contour is near the edges of the image (within a 10% margin)
    if area > max_area and (x < width * 0.1 or x + w > width * 0.9 or y < height * 0.1 or y + h > height * 0.9):
        largest_contour = cnt
        max_area = area

# Draw the bounding box and measurement lines if the largest contour is found
if largest_contour is not None:
    x, y, w, h = cv2.boundingRect(largest_contour)

    # Draw bounding box for visual confirmation
    output_image = image.copy()
    cv2.rectangle(output_image, (x, y), (x + w, y + h), (0, 255, 0), 5)

    # Draw measurement lines on the bounding box
    # Top green line
    cv2.line(output_image, (x, y), (x + w, y), (0, 255, 0), 5)
    cv2.putText(output_image, "Top Border", (x + 20, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

    # Bottom green line
    cv2.line(output_image, (x, y + h), (x + w, y + h), (0, 255, 0), 5)
    cv2.putText(output_image, "Bottom Border", (x + 20, y + h + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

    # Left blue line
    cv2.line(output_image, (x, y), (x, y + h), (255, 0, 0), 5)
    cv2.putText(output_image, "Left Border", (x - 70, y + h // 2), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

    # Right red line
    cv2.line(output_image, (x + w, y), (x + w, y + h), (0, 0, 255), 5)
    cv2.putText(output_image, "Right Border", (x + w + 10, y + h // 2), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

    # Display the final result
    plt.imshow(cv2.cvtColor(output_image, cv2.COLOR_BGR2RGB))
    plt.title("Detected Outer Black Border with Measurement Lines")
    plt.show()
else:
    print("No appropriate contour found near the image borders.")

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = "/mnt/data/36EEA805-E52C-4D35-8930-472331FEAFF3.jpeg"  # Update if needed
image = cv2.imread(image_path)
height, width = image.shape[:2]

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Canny edge detection
edges = cv2.Canny(gray, 50, 150)

# Find contours from the edge-detected image
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Initialize variable to store the largest rectangle-like contour
largest_rectangle = None
max_area = 0

# Loop through each contour to find rectangle-like shapes
for contour in contours:
    # Approximate the contour to a polygon
    epsilon = 0.02 * cv2.arcLength(contour, True)
    approx = cv2.approxPolyDP(contour, epsilon, True)
    
    # Check if the polygon has 4 vertices (rectangle-like)
    if len(approx) == 4:
        area = cv2.contourArea(contour)
        # Update the largest rectangle-like contour based on area
        if area > max_area:
            largest_rectangle = approx
            max_area = area

# Draw the detected rectangular contour if found
if largest_rectangle is not None:
    # Draw the outer rectangular contour on the image
    output_image = image.copy()
    cv2.drawContours(output_image, [largest_rectangle], -1, (0, 255, 0), 5)

    # Extract points for the rectangular contour
    points = largest_rectangle.reshape(4, 2)

    # Draw measurement lines on the rectangle
    # Line between top-left and top-right
    cv2.line(output_image, tuple(points[0]), tuple(points[1]), (255, 0, 0), 5)  # Top border
    cv2.putText(output_image, "Top Border", (points[0][0] + 20, points[0][1] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

    # Line between bottom-left and bottom-right
    cv2.line(output_image, tuple(points[2]), tuple(points[3]), (0, 255, 0), 5)  # Bottom border
    cv2.putText(output_image, "Bottom Border", (points[2][0] + 20, points[2][1] + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

    # Line between top-left and bottom-left
    cv2.line(output_image, tuple(points[0]), tuple(points[2]), (0, 0, 255), 5)  # Left border
    cv2.putText(output_image, "Left Border", (points[0][0] - 70, (points[0][1] + points[2][1]) // 2), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

    # Line between top-right and bottom-right
    cv2.line(output_image, tuple(points[1]), tuple(points[3]), (255, 255, 0), 5)  # Right border
    cv2.putText(output_image, "Right Border", (points[1][0] + 20, (points[1][1] + points[3][1]) // 2), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)

    # Display the final result
    plt.imshow(cv2.cvtColor(output_image, cv2.COLOR_BGR2RGB))
    plt.title("Detected Outer Rectangular Black Border with Measurement Lines")
    plt.show()
else:
    print("No rectangular contour found.")

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = "/mnt/data/36EEA805-E52C-4D35-8930-472331FEAFF3.jpeg"  # Update with the latest image if necessary
image = cv2.imread(image_path)
height, width = image.shape[:2]

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Canny edge detection
edges = cv2.Canny(gray, 50, 150, apertureSize=3)

# Apply Hough Line Transform to detect lines
lines = cv2.HoughLinesP(edges, 1, np.pi / 180, threshold=200, minLineLength=100, maxLineGap=10)

# Separate lines based on their orientation (horizontal or vertical)
horizontal_lines = []
vertical_lines = []

for line in lines:
    x1, y1, x2, y2 = line[0]
    if abs(y1 - y2) < 10:  # Horizontal line (y-coordinates are approximately equal)
        horizontal_lines.append(line[0])
    elif abs(x1 - x2) < 10:  # Vertical line (x-coordinates are approximately equal)
        vertical_lines.append(line[0])

# Identify the outermost horizontal and vertical lines
top_line = min(horizontal_lines, key=lambda l: l[1])  # Topmost horizontal line
bottom_line = max(horizontal_lines, key=lambda l: l[1])  # Bottommost horizontal line
left_line = min(vertical_lines, key=lambda l: l[0])  # Leftmost vertical line
right_line = max(vertical_lines, key=lambda l: l[0])  # Rightmost vertical line

# Draw the detected rectangular border on the original image
output_image = image.copy()
cv2.line(output_image, (top_line[0], top_line[1]), (top_line[2], top_line[3]), (0, 255, 0), 5)  # Green top line
cv2.line(output_image, (bottom_line[0], bottom_line[1]), (bottom_line[2], bottom_line[3]), (0, 255, 0), 5)  # Green bottom line
cv2.line(output_image, (left_line[0], left_line[1]), (left_line[2], left_line[3]), (255, 0, 0), 5)  # Blue left line
cv2.line(output_image, (right_line[0], right_line[1]), (right_line[2], right_line[3]), (0, 0, 255), 5)  # Red right line

# Display the final result
plt.imshow(cv2.cvtColor(output_image, cv2.COLOR_BGR2RGB))
plt.title("Detected Outer Rectangular Black Border with Measurement Lines")
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = "/mnt/data/BDBFCB4E-3813-459A-975D-7A4A4CE2BA49.jpeg"
image = cv2.imread(image_path)
height, width = image.shape[:2]

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Threshold to isolate dark (black) regions
_, thresh = cv2.threshold(gray, 50, 255, cv2.THRESH_BINARY_INV)

# Apply morphological closing to connect components
kernel = np.ones((10, 10), np.uint8)
closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

# Detect contours to find the black borders
contours, _ = cv2.findContours(closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Define minimum area and aspect ratio range for rectangular contours
min_area_threshold = 30000  # Area threshold to exclude small shapes
aspect_ratio_range = (1.5, 3.5)  # Aspect ratio range for rectangles

# Filter contours to keep only rectangular ones
filtered_contours = []
for cnt in contours:
    area = cv2.contourArea(cnt)
    if area > min_area_threshold:
        # Get the bounding rectangle for each contour
        x, y, w, h = cv2.boundingRect(cnt)
        aspect_ratio = float(w) / h
        
        # Check if the contour is rectangular based on aspect ratio
        if aspect_ratio_range[0] <= aspect_ratio <= aspect_ratio_range[1]:
            filtered_contours.append(cnt)

# Draw the filtered contour (outer rectangular border) for visual confirmation
contour_image = image.copy()
cv2.drawContours(contour_image, filtered_contours, -1, (0, 255, 0), 2)

# Find bounding box of the largest remaining contour (assumed to be the outer rectangular border)
outer_contour = max(filtered_contours, key=cv2.contourArea)
x, y, w, h = cv2.boundingRect(outer_contour)

# Draw the top green line across the top black border with thicker lines
top_line_y = y  # Top border of bounding box
cv2.line(image, (x, top_line_y), (x + w, top_line_y), (0, 255, 0), 5)  # Line thickness increased to 5
cv2.putText(image, "Top Border (55.58 mm)", (x + 20, top_line_y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

# Draw the left blue line along the left black border with thicker lines
left_line_x = x  # Left border of bounding box
cv2.line(image, (left_line_x, y), (left_line_x, y + h), (255, 0, 0), 5)  # Line thickness increased to 5
cv2.putText(image, "Left Border (Blue)", (left_line_x - 70, y + h // 2), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

# Draw the right red line along the right black border with thicker lines
right_line_x = x + w  # Right border of bounding box
cv2.line(image, (right_line_x, y), (right_line_x, y + h), (0, 0, 255), 5)  # Line thickness increased to 5
cv2.putText(image, "Right Border (Red)", (right_line_x + 10, y + h // 2), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

# Display the final result with adjusted borders and thicker lines
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title("Detected Rectangular Black Border with Measurement Lines")
plt.show()