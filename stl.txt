def draw_bounding_boxes_with_style(image, boxes, labels, confidences, pixel_to_mm_ratio):
    """
    Draw YOLO bounding boxes with thicker lines and visible text.
    """
    styled_image = image.copy()

    for i, box in enumerate(boxes):
        x1, y1, x2, y2 = map(int, box)
        width_mm = (x2 - x1) * pixel_to_mm_ratio
        height_mm = (y2 - y1) * pixel_to_mm_ratio

        # Draw bounding box with a thicker border
        cv2.rectangle(styled_image, (x1, y1), (x2, y2), (255, 0, 0), thickness=3)

        # Prepare label text with class and dimensions
        label = f"{labels[i]}: {width_mm:.2f} mm x {height_mm:.2f} mm ({confidences[i]*100:.1f}%)"

        # Draw text background rectangle
        text_size, baseline = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
        text_w, text_h = text_size
        cv2.rectangle(
            styled_image,
            (x1, y1 - text_h - 5),
            (x1 + text_w, y1),
            (255, 0, 0),
            thickness=cv2.FILLED,
        )

        # Put the label on top of the rectangle
        cv2.putText(
            styled_image,
            label,
            (x1, y1 - 5),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.6,
            (255, 255, 255),
            2,
        )

    return styled_image



import cv2
import numpy as np
import streamlit as st
from PIL import Image

st.set_page_config(page_title="Damage Estimations Demo", page_icon="üìè")

# Load YOLO model
with st.spinner("Loading YOLO model..."):
    yolo_model = model_Pred(
        best_model=r"C:\Users\castmar16\ASPIRE\cvdamage_webapp_\model\best.pt",
        data_yaml="cvde_coco_yolo_sn.yaml",
    )

def upload_image():
    """Function to upload an image."""
    image_file = st.file_uploader(label="Upload Image")
    if image_file is not None:
        size_mb = image_file.size / (1024 ** 2)
        file_details = {
            "filename": image_file.name,
            "filetype": image_file.type,
            "filesize": "{:.2f} MB".format(size_mb),
        }
        st.json(file_details)
        if file_details["filetype"] in ("image/png", "image/jpeg"):
            st.success("VALID IMAGE file type (png or jpeg)")
            return {"file": image_file, "details": file_details}
        else:
            st.error("INVALID Image file type")
            st.error("Upload only png, jpg, jpeg")
    return None

def detect_circles_contours(image):
    """Detect circles using contours."""
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (3, 3), 1)
    thresh = cv2.adaptiveThreshold(
        blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2
    )
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter == 0:
            continue
        circularity = 4 * np.pi * (area / (perimeter ** 2))
        if 0.7 < circularity < 1.3 and 5 < radius < 50:  # Refine these thresholds as needed
            circles.append((int(x), int(y), int(radius)))
    return circles

def calculate_pixel_to_mm_ratio(circles, known_distance_mm):
    """Calculate the pixel-to-mm ratio using the circles' distance."""
    if len(circles) >= 3:
        circles = sorted(circles, key=lambda c: c[0])  # Sort by x-coordinate
        x1, y1, _ = circles[0]
        x2, y2, _ = circles[2]  # Use the 1st and 3rd circle
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        return known_distance_mm / pixel_distance, ((x1, y1), (x2, y2))
    return None, None

def draw_circles_and_line(image, circles, line_coords, pixel_to_mm_ratio):
    """Draw detected circles, line, and show pixel-to-mm ratio."""
    processed_image = image.copy()
    for (x, y, r) in circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        diameter_mm = 2 * r * pixel_to_mm_ratio
        cv2.putText(
            processed_image,
            f"{diameter_mm:.2f} mm",
            (x - r, y - r - 10),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.5,
            (0, 255, 0),
            1,
        )
    # Draw the line
    if line_coords:
        cv2.line(processed_image, line_coords[0], line_coords[1], (255, 0, 0), 2)
    return processed_image

def draw_bounding_boxes(image, boxes, pixel_to_mm_ratio):
    """Draw YOLO bounding boxes and show dimensions in mm."""
    processed_image = image.copy()
    for box in boxes:
        x1, y1, x2, y2 = map(int, box)
        width_mm = (x2 - x1) * pixel_to_mm_ratio
        height_mm = (y2 - y1) * pixel_to_mm_ratio
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
        cv2.putText(
            processed_image,
            f"{width_mm:.2f} mm x {height_mm:.2f} mm",
            (x1, y1 - 10),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.5,
            (255, 255, 255),
            1,
        )
    return processed_image

def main():
    st.title("Damage Estimations Demo")
    obj = upload_image()
    if obj:
        image_obj = Image.open(obj["file"])
        st.image(image_obj, caption="Uploaded Image", use_column_width=True)
        image_array = np.array(image_obj)

        if st.button("Process Image"):
            with st.spinner("Processing image..."):
                # Detect circles and calculate pixel-to-mm ratio
                circles = detect_circles_contours(image_array)
                pixel_to_mm_ratio, line_coords = calculate_pixel_to_mm_ratio(circles, known_distance_mm=10)

                if not pixel_to_mm_ratio:
                    st.error("Failed to detect enough circles for pixel-to-mm conversion.")
                    return

                # Get YOLO predictions
                results = yolo_model.predictions(image_array)
                result = results[0]
                boxes = result.boxes.xyxy.cpu().numpy()  # Get bounding box coordinates

                # Draw everything
                processed_image = draw_circles_and_line(image_array, circles, line_coords, pixel_to_mm_ratio)
                final_image = draw_bounding_boxes(processed_image, boxes, pixel_to_mm_ratio)

                # Display processed image
                st.image(final_image, caption="Processed Image with Circles, Line, and Bounding Boxes", use_column_width=True)

                # Display bounding box measurements
                st.sidebar.subheader("Bounding Box Measurements (mm)")
                for box in boxes:
                    x1, y1, x2, y2 = box
                    width_mm = (x2 - x1) * pixel_to_mm_ratio
                    height_mm = (y2 - y1) * pixel_to_mm_ratio
                    st.sidebar.write(f"Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")

if __name__ == "__main__":
    main()