def filter_circles_by_proximity(circles):
    """
    Filter circles based on their proximity to each other.
    :param circles: List of detected circles [(x, y, radius)].
    :return: Filtered list of circles.
    """
    if len(circles) == 0:
        return []

    if len(circles) == 1:
        return circles  # Only one circle detected; use it as is.

    # Sort circles by their x-coordinates (horizontal alignment)
    circles = sorted(circles, key=lambda c: (c[1], c[0]))  # Sort by y (vertical), then x

    # Establish a maximum distance threshold (3 * the largest radius)
    max_radius = max([c[2] for c in circles])
    distance_threshold = 3 * max_radius

    # Start with the first circle and find the closest valid circles
    valid_circles = [circles[0]]
    for i in range(1, len(circles)):
        x1, y1, _ = valid_circles[-1]
        x2, y2, _ = circles[i]

        # Compute the Euclidean distance
        distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        if distance <= distance_threshold:
            valid_circles.append(circles[i])

    # If more than 3 circles remain, pick the closest 3
    if len(valid_circles) > 3:
        valid_circles = valid_circles[:3]

    return valid_circles



def filter_circles(detected_circles, max_distance_factor=3):
    """
    Filters detected circles based on their distances.
    - detected_circles: List of tuples (x, y, r).
    - max_distance_factor: Maximum allowable distance as a multiple of diameter.
    """
    if len(detected_circles) < 3:
        # Fallback: If fewer than 3 circles, return what is available
        return detected_circles

    # Sort circles by radius (largest first for consistency)
    detected_circles = sorted(detected_circles, key=lambda c: c[2], reverse=True)

    valid_circles = []
    max_radius = detected_circles[0][2]  # Use the largest radius
    max_distance = max_distance_factor * (2 * max_radius)

    for i in range(len(detected_circles)):
        valid_set = [detected_circles[i]]
        for j in range(i + 1, len(detected_circles)):
            dist = np.sqrt(
                (detected_circles[i][0] - detected_circles[j][0]) ** 2
                + (detected_circles[i][1] - detected_circles[j][1]) ** 2
            )
            if dist <= max_distance:
                valid_set.append(detected_circles[j])

        # Keep the largest valid set of circles
        if len(valid_set) >= 3:
            return valid_set[:3]  # Return the first 3 valid circles

        # Fallback: If fewer than 3 circles are valid, keep the largest set
        if len(valid_circles) < len(valid_set):
            valid_circles = valid_set

    return valid_circles if len(valid_circles) > 0 else [detected_circles[0]]




import numpy as np

def filter_circles_by_distance(circles, distance_factor=3):
    """
    Filters circles based on the distance between their centers.
    - circles: List of tuples (x, y, r) from detection.
    - distance_factor: The maximum allowable distance between centers
                       as a multiple of the diameter of the largest circle.
    """
    if len(circles) < 3:
        # If less than 3 circles, return the largest one (fallback).
        return [max(circles, key=lambda c: c[2])] if circles else []

    # Sort circles by radius (descending) to prioritize the largest one
    circles = sorted(circles, key=lambda c: c[2], reverse=True)

    # Use the largest circle's diameter as the reference
    largest_diameter = circles[0][2] * 2
    max_distance = distance_factor * largest_diameter

    # Filter circles based on the distance between their centers
    filtered_circles = [circles[0]]  # Always keep the largest circle
    for circle in circles[1:]:
        keep_circle = True
        for existing_circle in filtered_circles:
            distance = np.sqrt(
                (circle[0] - existing_circle[0]) ** 2 + (circle[1] - existing_circle[1]) ** 2
            )
            if distance > max_distance:
                keep_circle = False
                break
        if keep_circle:
            filtered_circles.append(circle)

    # If after filtering we still have more than 3 circles, take the closest 3
    if len(filtered_circles) > 3:
        filtered_circles = sorted(filtered_circles, key=lambda c: c[1])[:3]

    return filtered_circles








def filter_circles(circles, max_distance_factor=1.5, size_similarity_threshold=0.2):
    """
    Filters detected circles to identify valid ones for the line and measurement calculations.
    - circles: List of tuples (x, y, r) from detection.
    - max_distance_factor: Maximum distance between circles relative to their radius.
    - size_similarity_threshold: Threshold for size (radius) similarity.
    """
    if len(circles) < 3:
        # If less than 3 circles, return them as is (or just the first one).
        return circles[:1]  # Return one circle for fallback
    
    # Sort circles by their x-coordinate (horizontal alignment assumption).
    circles = sorted(circles, key=lambda c: c[0])
    
    valid_circles = []
    for i, (x1, y1, r1) in enumerate(circles):
        group = [(x1, y1, r1)]
        for j, (x2, y2, r2) in enumerate(circles[i + 1:], start=i + 1):
            distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
            
            # Check if the circles are close enough and similar in size
            if (
                distance <= max_distance_factor * r1
                and abs(r2 - r1) / max(r1, r2) <= size_similarity_threshold
            ):
                group.append((x2, y2, r2))
            
            # Stop if we already have 3 valid circles
            if len(group) == 3:
                break
        
        # If a valid group of 3 is found, add it to the results
        if len(group) == 3:
            valid_circles = group
            break
    
    # If no valid group of 3 is found, return the closest 3
    if not valid_circles and len(circles) >= 3:
        valid_circles = circles[:3]
    
    # If still no valid circles (edge case), return just the largest one
    if not valid_circles:
        valid_circles = [max(circles, key=lambda c: c[2])]  # Return the largest circle

    return valid_circles




def filter_circles_based_on_distance(circles, max_distance_ratio=3.0):
    """
    Filters circles based on distances between them. If one circle is too far, fallback to two circles or just one.
    - circles: List of detected circles [(x, y, radius)].
    - max_distance_ratio: Maximum allowed distance between circles as a multiple of the average radius.
    """
    if len(circles) < 2:
        return circles  # Not enough circles to filter

    # Calculate average radius
    radii = [circle[2] for circle in circles]
    avg_radius = np.mean(radii)

    # Calculate pairwise distances
    distances = []
    for i in range(len(circles)):
        for j in range(i + 1, len(circles)):
            dist = np.sqrt(
                (circles[i][0] - circles[j][0]) ** 2 +
                (circles[i][1] - circles[j][1]) ** 2
            )
            distances.append((dist, i, j))

    # Filter out pairs with distances exceeding the threshold
    valid_pairs = [
        (dist, i, j) for dist, i, j in distances if dist <= max_distance_ratio * avg_radius
    ]

    # Identify valid circles based on pairs
    valid_indices = set()
    for _, i, j in valid_pairs:
        valid_indices.add(i)
        valid_indices.add(j)

    # Fallback logic
    if len(valid_indices) >= 3:
        # If 3 or more circles are valid, keep the closest 3
        sorted_circles = sorted(valid_indices, key=lambda idx: radii[idx], reverse=True)
        return [circles[idx] for idx in sorted_circles[:3]]
    elif len(valid_indices) == 2:
        # If only 2 circles are valid, return them
        return [circles[idx] for idx in valid_indices]
    elif len(valid_indices) == 1:
        # If only 1 circle is valid, return it
        return [circles[next(iter(valid_indices))]]
    else:
        # If no valid circles, return the first detected circle as fallback
        return [circles[0]] if circles else []

mmm




import numpy as np
import cv2

def filter_circles_alignment_agnostic(circles, max_distance_ratio=3.0, size_tolerance=0.5):
    """
    Filters circles based on size and proximity, agnostic to alignment (horizontal, vertical, or diagonal).
    - circles: List of tuples [(x, y, radius)].
    - max_distance_ratio: Max allowed distance between circles relative to their average radius.
    - size_tolerance: Tolerance for radius variation (fraction of the average radius).
    """
    if len(circles) < 2:
        return circles

    # Calculate average radius
    radii = [circle[2] for circle in circles]
    avg_radius = np.mean(radii)

    # Filter by size consistency
    filtered_circles = [
        circle for circle in circles
        if (1 - size_tolerance) * avg_radius <= circle[2] <= (1 + size_tolerance) * avg_radius
    ]

    if len(filtered_circles) < 2:
        return filtered_circles[:2]  # Ensure at least two circles for distance calculation

    # Calculate distances between all pairs of circles
    distances = []
    for i in range(len(filtered_circles)):
        for j in range(i + 1, len(filtered_circles)):
            dist = np.sqrt(
                (filtered_circles[i][0] - filtered_circles[j][0]) ** 2 +
                (filtered_circles[i][1] - filtered_circles[j][1]) ** 2
            )
            distances.append((dist, i, j))

    # Sort distances and keep the closest pairs
    distances = sorted(distances, key=lambda x: x[0])
    selected_indices = set()
    for dist, i, j in distances:
        if dist <= max_distance_ratio * avg_radius:
            selected_indices.add(i)
            selected_indices.add(j)

    # Return up to 3 circles based on proximity and alignment
    return [filtered_circles[idx] for idx in sorted(selected_indices)[:3]]


def process_image_with_dynamic_filtering(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.6 < circularity < 1.4 and 5 < radius < 50:  # Adjust thresholds as needed
                detected_circles.append((int(x), int(y), int(radius)))

    # Apply alignment-agnostic filtering
    filtered_circles = filter_circles_alignment_agnostic(detected_circles)

    # Draw circles and lines
    processed_image = image.copy()
    line_coords = None

    if len(filtered_circles) >= 2:
        cv2.line(
            processed_image,
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
            (255, 0, 0), 3
        )
        line_coords = (
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
        )

    for (x, y, r) in filtered_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 3)  # Thicker circle
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, filtered_circles, line_coords








import numpy as np

def filter_circles_by_size_and_proximity(circles, max_distance_ratio=2.0, size_tolerance=0.5):
    """
    Filters circles based on size and proximity.
    - circles: List of tuples [(x, y, radius)].
    - max_distance_ratio: Max allowed distance between circles relative to their average radius.
    - size_tolerance: Tolerance for radius variation (fraction of the average radius).
    """
    if len(circles) < 2:
        return circles

    # Calculate average radius
    radii = [circle[2] for circle in circles]
    avg_radius = np.mean(radii)

    # Filter by size consistency
    filtered_circles = [
        circle for circle in circles
        if (1 - size_tolerance) * avg_radius <= circle[2] <= (1 + size_tolerance) * avg_radius
    ]

    # If fewer than 2 circles remain, fallback to one circle
    if len(filtered_circles) < 2:
        return filtered_circles[:1]

    # Filter by proximity
    result_circles = []
    for i in range(len(filtered_circles)):
        for j in range(i + 1, len(filtered_circles)):
            dist = np.sqrt(
                (filtered_circles[i][0] - filtered_circles[j][0]) ** 2 +
                (filtered_circles[i][1] - filtered_circles[j][1]) ** 2
            )
            # Include pairs that are close enough
            if dist <= max_distance_ratio * avg_radius:
                result_circles.append(filtered_circles[i])
                result_circles.append(filtered_circles[j])

    # Remove duplicates and limit to 3 closest circles
    result_circles = list(set(result_circles))
    result_circles = sorted(result_circles, key=lambda c: c[0])[:3]  # Sort by x-coordinate

    return result_circles


def process_image_with_filters(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.6 < circularity < 1.4 and 5 < radius < 50:  # Adjust thresholds as needed
                detected_circles.append((int(x), int(y), int(radius)))

    # Filter circles by size and proximity
    filtered_circles = filter_circles_by_size_and_proximity(detected_circles)

    # Draw circles and lines
    processed_image = image.copy()
    line_coords = None

    if len(filtered_circles) >= 2:
        cv2.line(
            processed_image,
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
            (255, 0, 0), 3
        )
        line_coords = (
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
        )

    for (x, y, r) in filtered_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 3)  # Thicker circle
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, filtered_circles, line_coords













def draw_bounding_boxes_on_image(image, boxes):
    """
    Draw bounding boxes with labels (bounding box number) on the image.
    
    :param image: The image to draw on.
    :param boxes: YOLO bounding boxes.
    """
    processed_image = image.copy()

    for idx, box in enumerate(boxes.xyxy.tolist(), start=1):
        # Extract bounding box coordinates
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]

        # Draw bounding box with thicker line
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), thickness=3)

        # Create label for the bounding box
        label = f"Box {idx}"

        # Add a background rectangle for the label
        text_size, baseline = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)
        text_width, text_height = text_size
        cv2.rectangle(processed_image, (x1, y1 - text_height - 5), (x1 + text_width, y1), (0, 255, 255), -1)

        # Put the label on the background rectangle
        cv2.putText(
            processed_image, label, (x1, y1 - 5),
            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), thickness=1, lineType=cv2.LINE_AA
        )

    return processed_image








def draw_bounding_boxes_on_image(image, boxes, pixel_to_mm_ratio):
    processed_image = image.copy()
    for idx, box in enumerate(boxes.xyxy.tolist(), start=1):
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), thickness=4)  # Thicker bounding box
        label = f"BB{idx}"  # Add the bounding box number
        cv2.putText(
            processed_image, label, (x1, y1 - 10),
            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), thickness=2
        )
    return processed_image





import streamlit as st
import cv2
import numpy as np
from PIL import Image

def process_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:
                detected_circles.append((int(x), int(y), int(radius)))

    detected_circles = sorted(detected_circles, key=lambda c: c[1])  # Sort by y-coordinate
    processed_image = image.copy()
    line_coords = None

    if len(detected_circles) >= 3:
        x1, y1, r1 = detected_circles[0]
        x3, y3, r3 = detected_circles[2]
        cv2.line(processed_image, (x1, y1 - r1), (x3, y3 - r3), (255, 0, 0), 2)
        line_coords = ((x1, y1 - r1), (x3, y3 - r3))
    elif len(detected_circles) == 2 or len(detected_circles) == 1:
        x, y, r = detected_circles[0]
        cv2.line(processed_image, (x, y - r), (x, y + r), (255, 0, 0), 2)
        line_coords = ((x, y - r), (x, y + r))
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, detected_circles, line_coords

def calculate_pixel_to_mm_ratio(detected_circles, line_coords):
    if len(detected_circles) >= 3 and line_coords:
        (x1, y1), (x2, y2) = line_coords
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        known_distance_mm = 10  # Known distance for 3 circles
        return known_distance_mm / pixel_distance
    elif len(detected_circles) >= 1:
        radius = detected_circles[0][2]
        return 2 / (2 * radius)  # Convert diameter in pixels
    else:
        return None

def draw_bounding_boxes_on_image(image, boxes):
    processed_image = image.copy()
    for box in boxes.xyxy.tolist():
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
    return processed_image

def get_image_prediction(image_obj, yolo, file=None):
    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes

        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        processed_img_with_boxes = draw_bounding_boxes_on_image(processed_image, pred_boxes)
        st.image(processed_img_with_boxes, caption="Processed Image with Circles, Line, and Bounding Boxes")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        if pixel_to_mm_ratio is not None:
            for i, box in enumerate(pred_boxes.xyxy.tolist(), start=1):
                x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
                width_px = x2 - x1
                height_px = y2 - y1
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Box {i}: Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
        else:
            st.write("Unable to calculate measurements (missing circles).")

def main():
    st.title("Image Processing with YOLO and Circle Detection")
    uploaded_file = st.file_uploader("Upload an image", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        image_obj = Image.open(uploaded_file)
        yolo = ...  # Load your YOLO model here
        get_image_prediction(image_obj, yolo, file=uploaded_file)

if __name__ == "__main__":
    main()













def draw_bounding_boxes_on_image(image, boxes):
    processed_image = image.copy()

    for i, box in enumerate(boxes.xyxy.tolist(), start=1):
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        # Draw bounding box with a thicker line
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)

    return processed_image

def get_image_prediction(image_obj, yolo, file=None):
    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes

        # Process the image to detect circles and draw line
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes on the processed image
        processed_img_with_boxes = draw_bounding_boxes_on_image(processed_image, pred_boxes)

        # Show the processed image
        st.image(processed_img_with_boxes, caption="Processed Image with Circles, Line, and Bounding Boxes")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        if pixel_to_mm_ratio is not None:
            for i, box in enumerate(pred_boxes.xyxy.tolist(), start=1):
                x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
                width_px = x2 - x1
                height_px = y2 - y1
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Box {i}: Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
        else:
            st.write("Unable to calculate measurements (missing circles).")












import cv2
import numpy as np
import streamlit as st
from PIL import Image


def process_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:
                detected_circles.append((int(x), int(y), int(radius)))

    detected_circles = sorted(detected_circles, key=lambda c: c[1])
    processed_image = image.copy()
    line_coords = None

    if len(detected_circles) >= 3:
        cv2.line(
            processed_image,
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1]),
            (255, 0, 0), 2
        )
        line_coords = (
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1])
        )

    for (x, y, r) in detected_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, detected_circles, line_coords


def calculate_pixel_to_mm_ratio(detected_circles, line_coords):
    if len(detected_circles) >= 3 and line_coords:
        # Use the line created by 3 circles
        (x1, y1), (x2, y2) = line_coords
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        known_distance_mm = 10  # Known distance for 3 circles
        return known_distance_mm / pixel_distance
    elif len(detected_circles) >= 1:
        # Use the diameter of one circle
        radius = detected_circles[0][2]
        return 2 / (2 * radius)  # Convert diameter in pixels
    else:
        return None


def draw_bounding_boxes_on_image(image, boxes, pixel_to_mm_ratio):
    processed_image = image.copy()
    for box in boxes.xyxy.tolist():
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
        if pixel_to_mm_ratio:
            width_px = x2 - x1
            height_px = y2 - y1
            width_mm = width_px * pixel_to_mm_ratio
            height_mm = height_px * pixel_to_mm_ratio
            text = f"{width_mm:.2f}mm x {height_mm:.2f}mm"
            cv2.putText(
                processed_image, text, (x1, y1 - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2
            )
    return processed_image


def get_image_prediction(image_obj, yolo, file=None):
    category_list = ["1", "2", "3", "4"]
    pred_df = {}
    if isinstance(file, str):
        pred_df["filename"] = file
    else:
        pred_df["filename"] = file.name

    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes
        pixel_to_mm_ratio = None
        pred_img = results[0].plot()

        # Process image for circle detection and line drawing
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes with measurements in mm
        processed_img_with_boxes = draw_bounding_boxes_on_image(
            processed_image, pred_boxes, pixel_to_mm_ratio
        )
        st.image(processed_img_with_boxes, caption="Processed Image with Predictions")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        for box in pred_boxes.xyxy.tolist():
            x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
            width_px = x2 - x1
            height_px = y2 - y1
            if pixel_to_mm_ratio:
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
            else:
                st.write("Unable to calculate measurements (missing circles).")

import streamlit as st
from PIL import Image
import numpy as np
import cv2


def main():
    st.set_page_config(page_title="Image Predictions with Measurements", page_icon="📏")

    # Sidebar for uploading image
    st.sidebar.header("Upload Image")
    image_obj = None
    file = st.sidebar.file_uploader("Upload an image (PNG or JPG)", type=["png", "jpg", "jpeg"])
    
    if file is not None:
        image_obj = Image.open(file)

    # Sidebar for loading YOLO model
    st.sidebar.header("Model Selection")
    st.sidebar.info("Loading YOLO model for predictions...")
    yolo_model = load_yolo_model()  # Replace with your YOLO model loading logic

    # Layout for the main content
    if image_obj is not None and yolo_model is not None:
        st.subheader("Image Predictions and Measurements")

        # Call the get_image_prediction function
        get_image_prediction(image_obj, yolo_model, file=file)
    else:
        st.warning("Please upload an image to start the prediction.")

    st.sidebar.write("---")
    st.sidebar.info("Developed by [Your Name].")

def load_yolo_model():
    """Loads the YOLO model for predictions."""
    with st.spinner("Loading YOLO model..."):
        # Replace with your model loading logic
        model = model_Pred(
            best_model=r"C:\path\to\model\best.pt", 
            data_yaml="cvde_coco_yolo_sn.yaml"
        )
        st.success("YOLO model loaded successfully!")
    return model


if __name__ == "__main__":
    main()
