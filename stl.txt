import numpy as np

def filter_circles_by_size_and_proximity(circles, max_distance_ratio=2.0, size_tolerance=0.5):
    """
    Filters circles based on size and proximity.
    - circles: List of tuples [(x, y, radius)].
    - max_distance_ratio: Max allowed distance between circles relative to their average radius.
    - size_tolerance: Tolerance for radius variation (fraction of the average radius).
    """
    if len(circles) < 2:
        return circles

    # Calculate average radius
    radii = [circle[2] for circle in circles]
    avg_radius = np.mean(radii)

    # Filter by size consistency
    filtered_circles = [
        circle for circle in circles
        if (1 - size_tolerance) * avg_radius <= circle[2] <= (1 + size_tolerance) * avg_radius
    ]

    # If fewer than 2 circles remain, fallback to one circle
    if len(filtered_circles) < 2:
        return filtered_circles[:1]

    # Filter by proximity
    result_circles = []
    for i in range(len(filtered_circles)):
        for j in range(i + 1, len(filtered_circles)):
            dist = np.sqrt(
                (filtered_circles[i][0] - filtered_circles[j][0]) ** 2 +
                (filtered_circles[i][1] - filtered_circles[j][1]) ** 2
            )
            # Include pairs that are close enough
            if dist <= max_distance_ratio * avg_radius:
                result_circles.append(filtered_circles[i])
                result_circles.append(filtered_circles[j])

    # Remove duplicates and limit to 3 closest circles
    result_circles = list(set(result_circles))
    result_circles = sorted(result_circles, key=lambda c: c[0])[:3]  # Sort by x-coordinate

    return result_circles


def process_image_with_filters(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.6 < circularity < 1.4 and 5 < radius < 50:  # Adjust thresholds as needed
                detected_circles.append((int(x), int(y), int(radius)))

    # Filter circles by size and proximity
    filtered_circles = filter_circles_by_size_and_proximity(detected_circles)

    # Draw circles and lines
    processed_image = image.copy()
    line_coords = None

    if len(filtered_circles) >= 2:
        cv2.line(
            processed_image,
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
            (255, 0, 0), 3
        )
        line_coords = (
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
        )

    for (x, y, r) in filtered_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 3)  # Thicker circle
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, filtered_circles, line_coords













def draw_bounding_boxes_on_image(image, boxes):
    """
    Draw bounding boxes with labels (bounding box number) on the image.
    
    :param image: The image to draw on.
    :param boxes: YOLO bounding boxes.
    """
    processed_image = image.copy()

    for idx, box in enumerate(boxes.xyxy.tolist(), start=1):
        # Extract bounding box coordinates
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]

        # Draw bounding box with thicker line
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), thickness=3)

        # Create label for the bounding box
        label = f"Box {idx}"

        # Add a background rectangle for the label
        text_size, baseline = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)
        text_width, text_height = text_size
        cv2.rectangle(processed_image, (x1, y1 - text_height - 5), (x1 + text_width, y1), (0, 255, 255), -1)

        # Put the label on the background rectangle
        cv2.putText(
            processed_image, label, (x1, y1 - 5),
            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), thickness=1, lineType=cv2.LINE_AA
        )

    return processed_image








def draw_bounding_boxes_on_image(image, boxes, pixel_to_mm_ratio):
    processed_image = image.copy()
    for idx, box in enumerate(boxes.xyxy.tolist(), start=1):
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), thickness=4)  # Thicker bounding box
        label = f"BB{idx}"  # Add the bounding box number
        cv2.putText(
            processed_image, label, (x1, y1 - 10),
            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), thickness=2
        )
    return processed_image





import streamlit as st
import cv2
import numpy as np
from PIL import Image

def process_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:
                detected_circles.append((int(x), int(y), int(radius)))

    detected_circles = sorted(detected_circles, key=lambda c: c[1])  # Sort by y-coordinate
    processed_image = image.copy()
    line_coords = None

    if len(detected_circles) >= 3:
        x1, y1, r1 = detected_circles[0]
        x3, y3, r3 = detected_circles[2]
        cv2.line(processed_image, (x1, y1 - r1), (x3, y3 - r3), (255, 0, 0), 2)
        line_coords = ((x1, y1 - r1), (x3, y3 - r3))
    elif len(detected_circles) == 2 or len(detected_circles) == 1:
        x, y, r = detected_circles[0]
        cv2.line(processed_image, (x, y - r), (x, y + r), (255, 0, 0), 2)
        line_coords = ((x, y - r), (x, y + r))
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, detected_circles, line_coords

def calculate_pixel_to_mm_ratio(detected_circles, line_coords):
    if len(detected_circles) >= 3 and line_coords:
        (x1, y1), (x2, y2) = line_coords
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        known_distance_mm = 10  # Known distance for 3 circles
        return known_distance_mm / pixel_distance
    elif len(detected_circles) >= 1:
        radius = detected_circles[0][2]
        return 2 / (2 * radius)  # Convert diameter in pixels
    else:
        return None

def draw_bounding_boxes_on_image(image, boxes):
    processed_image = image.copy()
    for box in boxes.xyxy.tolist():
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
    return processed_image

def get_image_prediction(image_obj, yolo, file=None):
    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes

        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        processed_img_with_boxes = draw_bounding_boxes_on_image(processed_image, pred_boxes)
        st.image(processed_img_with_boxes, caption="Processed Image with Circles, Line, and Bounding Boxes")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        if pixel_to_mm_ratio is not None:
            for i, box in enumerate(pred_boxes.xyxy.tolist(), start=1):
                x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
                width_px = x2 - x1
                height_px = y2 - y1
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Box {i}: Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
        else:
            st.write("Unable to calculate measurements (missing circles).")

def main():
    st.title("Image Processing with YOLO and Circle Detection")
    uploaded_file = st.file_uploader("Upload an image", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        image_obj = Image.open(uploaded_file)
        yolo = ...  # Load your YOLO model here
        get_image_prediction(image_obj, yolo, file=uploaded_file)

if __name__ == "__main__":
    main()













def draw_bounding_boxes_on_image(image, boxes):
    processed_image = image.copy()

    for i, box in enumerate(boxes.xyxy.tolist(), start=1):
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        # Draw bounding box with a thicker line
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)

    return processed_image

def get_image_prediction(image_obj, yolo, file=None):
    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes

        # Process the image to detect circles and draw line
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes on the processed image
        processed_img_with_boxes = draw_bounding_boxes_on_image(processed_image, pred_boxes)

        # Show the processed image
        st.image(processed_img_with_boxes, caption="Processed Image with Circles, Line, and Bounding Boxes")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        if pixel_to_mm_ratio is not None:
            for i, box in enumerate(pred_boxes.xyxy.tolist(), start=1):
                x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
                width_px = x2 - x1
                height_px = y2 - y1
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Box {i}: Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
        else:
            st.write("Unable to calculate measurements (missing circles).")












import cv2
import numpy as np
import streamlit as st
from PIL import Image


def process_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:
                detected_circles.append((int(x), int(y), int(radius)))

    detected_circles = sorted(detected_circles, key=lambda c: c[1])
    processed_image = image.copy()
    line_coords = None

    if len(detected_circles) >= 3:
        cv2.line(
            processed_image,
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1]),
            (255, 0, 0), 2
        )
        line_coords = (
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1])
        )

    for (x, y, r) in detected_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, detected_circles, line_coords


def calculate_pixel_to_mm_ratio(detected_circles, line_coords):
    if len(detected_circles) >= 3 and line_coords:
        # Use the line created by 3 circles
        (x1, y1), (x2, y2) = line_coords
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        known_distance_mm = 10  # Known distance for 3 circles
        return known_distance_mm / pixel_distance
    elif len(detected_circles) >= 1:
        # Use the diameter of one circle
        radius = detected_circles[0][2]
        return 2 / (2 * radius)  # Convert diameter in pixels
    else:
        return None


def draw_bounding_boxes_on_image(image, boxes, pixel_to_mm_ratio):
    processed_image = image.copy()
    for box in boxes.xyxy.tolist():
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
        if pixel_to_mm_ratio:
            width_px = x2 - x1
            height_px = y2 - y1
            width_mm = width_px * pixel_to_mm_ratio
            height_mm = height_px * pixel_to_mm_ratio
            text = f"{width_mm:.2f}mm x {height_mm:.2f}mm"
            cv2.putText(
                processed_image, text, (x1, y1 - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2
            )
    return processed_image


def get_image_prediction(image_obj, yolo, file=None):
    category_list = ["1", "2", "3", "4"]
    pred_df = {}
    if isinstance(file, str):
        pred_df["filename"] = file
    else:
        pred_df["filename"] = file.name

    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes
        pixel_to_mm_ratio = None
        pred_img = results[0].plot()

        # Process image for circle detection and line drawing
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes with measurements in mm
        processed_img_with_boxes = draw_bounding_boxes_on_image(
            processed_image, pred_boxes, pixel_to_mm_ratio
        )
        st.image(processed_img_with_boxes, caption="Processed Image with Predictions")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        for box in pred_boxes.xyxy.tolist():
            x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
            width_px = x2 - x1
            height_px = y2 - y1
            if pixel_to_mm_ratio:
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
            else:
                st.write("Unable to calculate measurements (missing circles).")

import streamlit as st
from PIL import Image
import numpy as np
import cv2


def main():
    st.set_page_config(page_title="Image Predictions with Measurements", page_icon="📏")

    # Sidebar for uploading image
    st.sidebar.header("Upload Image")
    image_obj = None
    file = st.sidebar.file_uploader("Upload an image (PNG or JPG)", type=["png", "jpg", "jpeg"])
    
    if file is not None:
        image_obj = Image.open(file)

    # Sidebar for loading YOLO model
    st.sidebar.header("Model Selection")
    st.sidebar.info("Loading YOLO model for predictions...")
    yolo_model = load_yolo_model()  # Replace with your YOLO model loading logic

    # Layout for the main content
    if image_obj is not None and yolo_model is not None:
        st.subheader("Image Predictions and Measurements")

        # Call the get_image_prediction function
        get_image_prediction(image_obj, yolo_model, file=file)
    else:
        st.warning("Please upload an image to start the prediction.")

    st.sidebar.write("---")
    st.sidebar.info("Developed by [Your Name].")

def load_yolo_model():
    """Loads the YOLO model for predictions."""
    with st.spinner("Loading YOLO model..."):
        # Replace with your model loading logic
        model = model_Pred(
            best_model=r"C:\path\to\model\best.pt", 
            data_yaml="cvde_coco_yolo_sn.yaml"
        )
        st.success("YOLO model loaded successfully!")
    return model


if __name__ == "__main__":
    main()
