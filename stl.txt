def draw_bounding_boxes_on_image(image, boxes):
    processed_image = image.copy()

    for i, box in enumerate(boxes.xyxy.tolist(), start=1):
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        # Draw bounding box with a thicker line
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)

    return processed_image

def get_image_prediction(image_obj, yolo, file=None):
    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes

        # Process the image to detect circles and draw line
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes on the processed image
        processed_img_with_boxes = draw_bounding_boxes_on_image(processed_image, pred_boxes)

        # Show the processed image
        st.image(processed_img_with_boxes, caption="Processed Image with Circles, Line, and Bounding Boxes")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        if pixel_to_mm_ratio is not None:
            for i, box in enumerate(pred_boxes.xyxy.tolist(), start=1):
                x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
                width_px = x2 - x1
                height_px = y2 - y1
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Box {i}: Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
        else:
            st.write("Unable to calculate measurements (missing circles).")












import cv2
import numpy as np
import streamlit as st
from PIL import Image


def process_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:
                detected_circles.append((int(x), int(y), int(radius)))

    detected_circles = sorted(detected_circles, key=lambda c: c[1])
    processed_image = image.copy()
    line_coords = None

    if len(detected_circles) >= 3:
        cv2.line(
            processed_image,
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1]),
            (255, 0, 0), 2
        )
        line_coords = (
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1])
        )

    for (x, y, r) in detected_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, detected_circles, line_coords


def calculate_pixel_to_mm_ratio(detected_circles, line_coords):
    if len(detected_circles) >= 3 and line_coords:
        # Use the line created by 3 circles
        (x1, y1), (x2, y2) = line_coords
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        known_distance_mm = 10  # Known distance for 3 circles
        return known_distance_mm / pixel_distance
    elif len(detected_circles) >= 1:
        # Use the diameter of one circle
        radius = detected_circles[0][2]
        return 2 / (2 * radius)  # Convert diameter in pixels
    else:
        return None


def draw_bounding_boxes_on_image(image, boxes, pixel_to_mm_ratio):
    processed_image = image.copy()
    for box in boxes.xyxy.tolist():
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
        if pixel_to_mm_ratio:
            width_px = x2 - x1
            height_px = y2 - y1
            width_mm = width_px * pixel_to_mm_ratio
            height_mm = height_px * pixel_to_mm_ratio
            text = f"{width_mm:.2f}mm x {height_mm:.2f}mm"
            cv2.putText(
                processed_image, text, (x1, y1 - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2
            )
    return processed_image


def get_image_prediction(image_obj, yolo, file=None):
    category_list = ["1", "2", "3", "4"]
    pred_df = {}
    if isinstance(file, str):
        pred_df["filename"] = file
    else:
        pred_df["filename"] = file.name

    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes
        pixel_to_mm_ratio = None
        pred_img = results[0].plot()

        # Process image for circle detection and line drawing
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes with measurements in mm
        processed_img_with_boxes = draw_bounding_boxes_on_image(
            processed_image, pred_boxes, pixel_to_mm_ratio
        )
        st.image(processed_img_with_boxes, caption="Processed Image with Predictions")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        for box in pred_boxes.xyxy.tolist():
            x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
            width_px = x2 - x1
            height_px = y2 - y1
            if pixel_to_mm_ratio:
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
            else:
                st.write("Unable to calculate measurements (missing circles).")

import streamlit as st
from PIL import Image
import numpy as np
import cv2


def main():
    st.set_page_config(page_title="Image Predictions with Measurements", page_icon="üìè")

    # Sidebar for uploading image
    st.sidebar.header("Upload Image")
    image_obj = None
    file = st.sidebar.file_uploader("Upload an image (PNG or JPG)", type=["png", "jpg", "jpeg"])
    
    if file is not None:
        image_obj = Image.open(file)

    # Sidebar for loading YOLO model
    st.sidebar.header("Model Selection")
    st.sidebar.info("Loading YOLO model for predictions...")
    yolo_model = load_yolo_model()  # Replace with your YOLO model loading logic

    # Layout for the main content
    if image_obj is not None and yolo_model is not None:
        st.subheader("Image Predictions and Measurements")

        # Call the get_image_prediction function
        get_image_prediction(image_obj, yolo_model, file=file)
    else:
        st.warning("Please upload an image to start the prediction.")

    st.sidebar.write("---")
    st.sidebar.info("Developed by [Your Name].")

def load_yolo_model():
    """Loads the YOLO model for predictions."""
    with st.spinner("Loading YOLO model..."):
        # Replace with your model loading logic
        model = model_Pred(
            best_model=r"C:\path\to\model\best.pt", 
            data_yaml="cvde_coco_yolo_sn.yaml"
        )
        st.success("YOLO model loaded successfully!")
    return model


if __name__ == "__main__":
    main()
