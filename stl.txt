if st.button("Edit Circles"):
    corrected_circles = interactive_circle_editor(image_array, detected_circles)
    st.session_state[f"corrected_circles_{file.name}"] = corrected_circles
    st.success("Circles updated!")
    # Optionally show updated image
    corrected_image = save_corrected_image(image_array, corrected_circles)
    st.image(corrected_image, caption=f"Corrected Circles for {file.name}")



from streamlit_drawable_canvas import st_canvas
from PIL import ImageDraw

def interactive_circle_editor(image_array, detected_circles):
    """
    Use Streamlit Canvas to interactively edit circles.
    """

    # Convert the image to RGB for display
    image_pil = Image.fromarray(cv2.cvtColor(image_array, cv2.COLOR_BGR2RGB))

    # Draw initial circles on the image
    draw = ImageDraw.Draw(image_pil)
    for x, y, r in detected_circles:
        draw.ellipse((x-r, y-r, x+r, y+r), outline="red", width=3)

    st.info("Left-click on the canvas to draw a new circle or move existing ones.")
    st.info("Drag and resize circles as needed.")

    # Create the canvas
    canvas_result = st_canvas(
        fill_color="rgba(0, 0, 0, 0)",  # Transparent canvas
        stroke_width=2,
        stroke_color="red",
        background_image=image_pil,
        update_streamlit=True,
        height=image_pil.height,
        width=image_pil.width,
        drawing_mode="circle",
        display_toolbar=True,
        key="circle_editor",
    )

    # Collect the updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        for obj in canvas_result.json_data["objects"]:
            x, y = obj["left"], obj["top"]
            radius = obj["width"] / 2  # Assuming it's drawn as a circle
            updated_circles.append((x, y, radius))

    return updated_circles










import streamlit as st
import cv2
import numpy as np
from PIL import Image
import tempfile

def manual_correction_streamlit(image_array, detected_circles):
    corrected_circles = detected_circles.copy()  # Copy the initial detected circles
    avg_radius = int(np.mean([c[2] for c in detected_circles])) if detected_circles else 25

    def click_event(event, x, y, flags, param):
        nonlocal corrected_circles
        if event == cv2.EVENT_LBUTTONDOWN:  # Add a circle on left click
            corrected_circles.append((x, y, avg_radius))
            print(f"Circle added at ({x}, {y}) with radius {avg_radius}")
            update_display(corrected_circles)

        elif event == cv2.EVENT_RBUTTONDOWN:  # Remove the nearest circle on right click
            for i, (cx, cy, cr) in enumerate(corrected_circles):
                distance = np.sqrt((cx - x)**2 + (cy - y)**2)
                if distance <= cr:
                    print(f"Circle removed at ({cx}, {cy})")
                    corrected_circles.pop(i)
                    break
            update_display(corrected_circles)

    def draw_circles(img, circles):
        img_copy = img.copy()
        for x, y, r in circles:
            cv2.circle(img_copy, (x, y), r, (0, 255, 0), 2)
        return img_copy

    def update_display(circles):
        img_with_circles = draw_circles(image_array, circles)
        st.image(img_with_circles, caption="Edit Circles: Left-click to add, Right-click to remove", channels="BGR")

    # Initial display
    st.write("Left click to add a circle, right click to remove a circle.")
    update_display(corrected_circles)

    # Save corrected circles when done
    if st.button("Save Corrected Circles"):
        return corrected_circles

    return corrected_circles




def draw_circles_and_adaptive_line(image, circles, title="Circles and Adaptive Line"):
    import cv2
    import numpy as np

    # Create a copy of the image to draw on
    output = image.copy()

    # Draw the circles
    for (x, y, r) in circles:
        cv2.circle(output, (x, y), r, (0, 255, 0), 2)  # Green circle boundary
        cv2.circle(output, (x, y), 2, (0, 0, 255), -1)  # Red center dot

    # Check if circles are aligned more vertically or horizontally
    xs = [c[0] for c in circles]
    ys = [c[1] for c in circles]
    x_range = max(xs) - min(xs)
    y_range = max(ys) - min(ys)

    if y_range >= x_range:  # Vertical alignment
        # Sort circles by y-coordinate for vertical alignment
        sorted_circles = sorted(circles, key=lambda c: c[1])

        # Calculate line endpoints based on the circles' radii
        first_circle = sorted_circles[0]
        last_circle = sorted_circles[-1]
        mean_x = int(np.mean([c[0] for c in sorted_circles]))  # Use the average x-coordinate

        # Line starts at the top edge of the first circle
        start_point = (mean_x, first_circle[1] - first_circle[2])

        # Line ends at the bottom edge of the last circle
        end_point = (mean_x, last_circle[1] + last_circle[2])

    else:  # Horizontal alignment
        # Sort circles by x-coordinate for horizontal alignment
        sorted_circles = sorted(circles, key=lambda c: c[0])

        # Calculate line endpoints based on the circles' radii
        first_circle = sorted_circles[0]
        last




def adaptive_sort_circles(circles):
    """
    Adaptively sort circles based on their dominant alignment.
    :param circles: List of detected circles [(x, y, radius)].
    :return: Sorted list of circles.
    """
    if len(circles) < 2:
        return circles  # No sorting needed for fewer than 2 circles

    # Calculate the range of x and y coordinates
    x_coords = [c[0] for c in circles]
    y_coords = [c[1] for c in circles]
    x_range = max(x_coords) - min(x_coords)
    y_range = max(y_coords) - min(y_coords)

    # Determine dominant alignment
    if x_range > y_range:
        # Horizontal alignment
        sorted_circles = sorted(circles, key=lambda c: c[0])  # Sort by x
    else:
        # Vertical alignment
        sorted_circles = sorted(circles, key=lambda c: c[1])  # Sort by y

    return sorted_circles




def proximity_based_filtering_v2(circles, max_distance_factor=8.0):
    """
    Filter circles based on proximity.
    - Keeps groups of 3 circles if possible.
    - Falls back to 2 circles if no valid groups of 3 exist.
    """
    if not circles:
        return []

    # Step 1: Compute pairwise distances between circle centers
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor
    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")

    # Step 2: Group circles based on proximity
    valid_groups = []
    potential_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]

        # Consider groups of at least 3 circles as valid
        if len(group) >= 3:
            valid_groups.append(group)
        # Collect potential groups of exactly 2 circles
        elif len(group) == 2:
            potential_groups.append(group)

    # Step 3: Select the closest group of 3 circles
    if valid_groups:
        valid_groups.sort(
            key=lambda group: np.sum(distance.pdist([(c[0], c[1]) for c in group]))
        )
        filtered_circles = valid_groups[0][:3]  # Get only the 3 closest circles
    elif potential_groups:
        # Fallback 1: Handle groups with exactly 2 circles
        potential_groups.sort(
            key=lambda group: np.sum(distance.pdist([(c[0], c[1]) for c in group]))
        )
        filtered_circles = potential_groups[0]  # Return the 2 closest circles
    else:
        # Fallback 2: If no valid groups at all, return the circle closest to the average radius
        filtered_circles = [
            min(circles, key=lambda c: abs(c[2] - avg_radius))
        ]

    return filtered_circles


def draw_circles_and_line(image, circles, title):
    """
    Draws circles and lines connecting them on the image.
    Args:
        image (numpy.ndarray): The input image.
        circles (list): List of circles [(x, y, radius), ...].
        title (str): Title for the displayed image.
    """
    output = image.copy()
    if len(circles) > 0:
        for (x, y, r) in circles:
            # Ensure radius is an integer
            cv2.circle(output, (int(x), int(y)), int(r), (0, 255, 0), 2)  # Green circle boundary
            cv2.circle(output, (int(x), int(y)), 3, (0, 0, 255), -1)  # Red circle center
        
        # Draw a line connecting the centers of the circles
        for i in range(len(circles) - 1):
            cv2.line(output, (int(circles[i][0]), int(circles[i][1])),
                     (int(circles[i + 1][0]), int(circles[i + 1][1])), (255, 0, 0), 2)

    # Display the image
    cv2.imshow(title, output)
    cv2.waitKey(0)
    cv2.destroyAllWindows()



def proximity_based_filtering(circles, max_distance_factor=8.0):
    """
    Filters circles based on proximity and returns the three most relevant circles.

    Args:
        circles (list): List of detected circles [(x, y, radius), ...].
        max_distance_factor (float): Factor to multiply with the average radius for distance threshold.

    Returns:
        list: List of filtered circles [(x, y, radius), ...].
    """
    if not circles:
        return []

    # Step 1: Calculate distances and define thresholds
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor

    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")

    # Step 2: Group circles based on proximity
    valid_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]
        if len(group) >= 3:  # Only consider groups with at least 3 circles
            valid_groups.append(group)

    # Step 3: Select the closest group of 3 circles
    if valid_groups:
        valid_groups.sort(key=lambda group: np.sum(distance.pdist([(c[0], c[1]) for c in group])))
        filtered_circles = valid_groups[0][:3]  # Get only the 3 closest circles
    else:
        # Fallback 1: Handle groups with exactly 2 circles
        potential_groups = []
        for i in range(len(circles)):
            close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
            group = [circles[idx] for idx in close_indices]
            if len(group) == 2:
                potential_groups.append(group)

        if potential_groups:
            # Choose the closest group of 2 circles and estimate a third circle
            potential_groups.sort(key=lambda group: np.sum(distance.pdist([(c[0], c[1]) for c in group])))
            best_group = potential_groups[0]

            # Estimate the third circle as the midpoint between the two circles
            c1, c2 = best_group
            midpoint = ((c1[0] + c2[0]) // 2, (c1[1] + c2[1]) // 2)
            estimated_radius = avg_radius
            filtered_circles = [c1, c2, (midpoint[0], midpoint[1], estimated_radius)]
        else:
            # Fallback 2: If no valid groups at all, return the circle closest to the average radius
            filtered_circles = [min(circles, key=lambda c: abs(c[2] - avg_radius))]

    return filtered_circles





from scipy.spatial import distance

def refined_proximity_filtering(circles, max_distance_factor=8.0, retry_factor=1.5):
    if not circles:
        return []

    # Step 1: Compute pairwise distances and initial distance threshold
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor
    print(f"Average Radius: {avg_radius}")
    print(f"Initial Max Distance: {max_distance}")
    
    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")

    # Step 2: Group circles based on proximity
    valid_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]
        if len(group) >= 3:  # Only consider groups with at least 3 circles
            valid_groups.append(group)

    # Debugging: Print detected groups
    print(f"Valid Groups Detected: {len(valid_groups)}")

    # Step 3: Select the best group
    if valid_groups:
        # Select the group with the smallest overall distances
        best_group = min(valid_groups, key=lambda g: sum(distance.pdist([(c[0], c[1]) for c in g])))
        return sorted(best_group[:3], key=lambda c: c[0])  # Return only the top 3 closest circles

    # Step 4: Retry with a looser distance threshold if no valid groups
    if len(circles) >= 3:
        max_distance *= retry_factor  # Loosen the distance threshold
        print(f"Retrying with Max Distance: {max_distance}")
        valid_groups = []
        for i in range(len(circles)):
            close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
            group = [circles[idx] for idx in close_indices]
            if len(group) >= 3:
                valid_groups.append(group)

        if valid_groups:
            best_group = min(valid_groups, key=lambda g: sum(distance.pdist([(c[0], c[1]) for c in g])))
            return sorted(best_group[:3], key=lambda c: c[0])

    # Step 5: Fallback: Return the 3 circles closest to the geometric center
    if len(circles) >= 3:
        centroid = np.mean(centers, axis=0)
        closest_to_centroid = sorted(circles, key=lambda c: np.linalg.norm((c[0] - centroid[0], c[1] - centroid[1])))
        print(f"Falling back to centroid-based filtering: {closest_to_centroid[:3]}")
        return closest_to_centroid[:3]

    # Final fallback: Return all detected circles if fewer than 3
    print("Final fallback: Returning all detected circles")
    return circles



from scipy.spatial import distance

def enhanced_proximity_filtering(circles, max_distance_factor=8.0, retry_factor=2.0):
    if not circles:
        return []

    # Step 1: Compute pairwise distances and initial distance threshold
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor
    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")

    # Step 2: Group circles based on proximity
    valid_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]
        if len(group) >= 3:  # Only consider groups with at least 3 circles
            valid_groups.append(group)

    # Step 3: Select the best group
    if valid_groups:
        best_group = max(valid_groups, key=lambda g: len(g))  # Largest group
        return sorted(best_group[:3], key=lambda c: c[0])  # Limit to 3 circles and sort by x-coordinate

    # Step 4: Retry with a less restrictive distance threshold if no valid groups
    if len(circles) >= 3:
        print("No valid groups found; retrying with a looser distance threshold.")
        max_distance *= retry_factor  # Loosen the distance threshold
        valid_groups = []
        for i in range(len(circles)):
            close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
            group = [circles[idx] for idx in close_indices]
            if len(group) >= 3:
                valid_groups.append(group)

        if valid_groups:
            best_group = max(valid_groups, key=lambda g: len(g))
            return sorted(best_group[:3], key=lambda c: c[0])

    # Step 5: Fallback: Select closest circles to the geometric center
    if len(circles) >= 3:
        centroid = np.mean(centers, axis=0)
        closest_to_centroid = sorted(circles, key=lambda c: np.linalg.norm((c[0] - centroid[0], c[1] - centroid[1])))
        return closest_to_centroid[:3]

    # Final fallback: Return all detected circles (if fewer than 3)
    return circles



from scipy.spatial import distance

def refined_proximity_filtering_v2(circles, max_distance_factor=8.0):
    if not circles:
        return []

    # Step 1: Compute pairwise distances and identify max distance threshold
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor
    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")

    # Step 2: Group circles based on proximity
    valid_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]
        if len(group) >= 2:  # Allow groups with at least 2 circles for now
            valid_groups.append(group)

    # Step 3: Filter groups based on size and alignment
    filtered_groups = []
    for group in valid_groups:
        if len(group) >= 3:  # Prioritize groups with 3 circles
            filtered_groups.append(group)
        else:
            # Check alignment for 2-circle groups
            group_centers = np.array([(c[0], c[1]) for c in group])
            if len(group_centers) == 2:
                dx = abs(group_centers[0, 0] - group_centers[1, 0])
                dy = abs(group_centers[0, 1] - group_centers[1, 1])
                if dx < max_distance * 0.5 or dy < max_distance * 0.5:
                    filtered_groups.append(group)

    # Step 4: Select the best group
    if filtered_groups:
        best_group = max(filtered_groups, key=lambda g: len(g))  # Select group with most circles
        return sorted(best_group[:3], key=lambda c: c[0])  # Limit to 3 circles and sort by x-coordinate

    # Fallback: Select circles closest to geometric center
    if len(circles) >= 3:
        centroid = np.mean(centers, axis=0)
        closest_to_centroid = sorted(circles, key=lambda c: np.linalg.norm((c[0] - centroid[0], c[1] - centroid[1])))
        return closest_to_centroid[:3]
    elif len(circles) == 2:
        return circles  # Return the two circles detected
    elif len(circles) == 1:
        return circles  # Return the single circle detected
    else:
        return []

---

### Key Changes
1. **Allow 2-Circle Groups**:
   - In cases where fewer than three circles are detected, relax the criteria and retain the closest two.

2. **Fallback Using Geometric Center**:
   - For cases where no valid groups exist, find the geometric center of all detected circles and select those closest to it.

3. **Dynamic Adjustment**:
   - The maximum distance factor dynamically adapts based on the number of circles.

---

### Debugging Tips
- Print group details during filtering:
  ```python
  print(f"Found {len(valid_groups)} valid groups.")
  for group in valid_groups:
      print("Group:", group)




from scipy.spatial import distance

def refined_proximity_filtering(circles, max_distance_factor=8.0):
    if not circles:
        return []

    # Step 1: Compute pairwise distances and identify max distance threshold
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor
    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")

    # Step 2: Group circles based on proximity
    valid_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]
        if len(group) >= 2:  # Allow groups with at least 2 circles for now
            valid_groups.append(group)

    # Step 3: Filter valid groups based on alignment and size
    filtered_groups = []
    for group in valid_groups:
        group_centers = np.array([(c[0], c[1]) for c in group])
        if len(group) >= 3:  # Prioritize groups with 3 circles
            filtered_groups.append(group)
        else:
            # Check alignment of 2-circle groups (horizontal or vertical alignment)
            dx = abs(group_centers[0, 0] - group_centers[1, 0])
            dy = abs(group_centers[0, 1] - group_centers[1, 1])
            if dx < max_distance * 0.5 or dy < max_distance * 0.5:
                filtered_groups.append(group)

    # Step 4: Select the best group
    if filtered_groups:
        best_group = max(filtered_groups, key=lambda g: len(g))  # Select group with most circles
        return sorted(best_group[:3], key=lambda c: c[0])  # Limit to 3 circles and sort by x-coordinate

    # Fallback: If no valid groups, return closest circles to average radius
    return sorted(circles, key=lambda c: abs(c[2] - avg_radius))[:3]

def refined_proximity_filtering_debug(circles, max_distance_factor=8.0, radius_deviation_factor=0.5):
    """
    Filters circles based on proximity and radius consistency, with debugging output.

    Args:
        circles (list of tuples): List of detected circles [(x, y, r), ...].
        max_distance_factor (float): Factor to determine the maximum allowable distance for grouping circles.
        radius_deviation_factor (float): Threshold for excluding groups with high radius deviation.

    Returns:
        list: Filtered circles.
    """
    if not circles:
        print("No circles detected.")
        return []

    # Step 1: Compute pairwise distances and radii
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor

    print(f"Average Radius: {avg_radius}")
    print(f"Max Distance: {max_distance}")

    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")

    # Step 2: Group circles based on proximity and radius consistency
    valid_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]
        if len(group) >= 3:  # At least 3 circles needed in a group
            group_radii = [c[2] for c in group]
            radius_std_dev = np.std(group_radii)
            print(f"Group radii: {group_radii}, Std Dev: {radius_std_dev}")
            if radius_std_dev < avg_radius * radius_deviation_factor:
                valid_groups.append(group)

    # Step 3: Select the best group
    if valid_groups:
        # Rank groups by radius consistency
        valid_groups.sort(key=lambda group: np.std([c[2] for c in group]))
        filtered_circles = valid_groups[0][:3]  # Get only the best 3 circles
        print(f"Selected Group: {filtered_circles}")
    else:
        # Fallback: Return the circle closest to the average radius
        closest_circle = min(circles, key=lambda c: abs(c[2] - avg_radius))
        print(f"No valid groups found. Using closest circle: {closest_circle}")
        filtered_circles = [closest_circle]

    return filtered_circles






import cv2
import numpy as np

def show_image_fitting_screen(window_name, image):
    # Get screen resolution
    screen_width = 1366  # You can dynamically get this with libraries like pygetwindow
    screen_height = 768

    # Get image dimensions
    img_height, img_width = image.shape[:2]

    # Scale the image to fit screen dimensions
    scale_width = screen_width / img_width
    scale_height = screen_height / img_height
    scale = min(scale_width, scale_height)  # Choose the smaller scale factor

    new_width = int(img_width * scale)
    new_height = int(img_height * scale)

    # Resize the image
    resized_image = cv2.resize(image, (new_width, new_height), interpolation=cv2.INTER_AREA)

    # Create resizable window
    cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
    cv2.resizeWindow(window_name, new_width, new_height)

    # Display the image
    cv2.imshow(window_name, resized_image)

# Example usage in your code
while True:
    # Show resized image
    show_image_fitting_screen("Manual Circle Correction", image_copy)
    
    key = cv2.waitKey(1) & 0xFF
    if key == 27:  # Press 'ESC' to save and exit
        break

cv2.destroyAllWindows()







import numpy as np
from scipy.spatial import distance

def proximity_based_filtering(circles, max_distance_factor=3.0):
    """
    Filter circles based on their proximity to each other.

    Parameters:
        circles (list): List of detected circles [(x, y, radius), ...].
        max_distance_factor (float): Maximum allowable distance between centers as a factor of average radius.

    Returns:
        filtered_circles (list): List of filtered circles.
    """
    if not circles:
        return []

    # Step 1: Compute pairwise distances between circle centers
    centers = np.array([(c[0], c[1]) for c in circles])
    radii = np.array([c[2] for c in circles])
    avg_radius = np.mean(radii)
    max_distance = avg_radius * max_distance_factor

    pairwise_distances = distance.cdist(centers, centers, metric="euclidean")
    
    # Step 2: Group circles based on proximity
    valid_groups = []
    for i in range(len(circles)):
        close_indices = np.where(pairwise_distances[i] <= max_distance)[0]
        group = [circles[idx] for idx in close_indices]
        if len(group) >= 3:  # Only consider groups with at least 3 circles
            valid_groups.append(group)

    # Step 3: Select the closest group with 3 circles, fallback to largest radius if no groups
    if valid_groups:
        # Select the group with the smallest overall distances
        valid_groups.sort(key=lambda group: np.sum(distance.pdist([(c[0], c[1]) for c in group])))
        filtered_circles = valid_groups[0][:3]  # Get only 3 closest circles
    else:
        # Fallback: If no valid groups, return the largest radius circle
        filtered_circles = [max(circles, key=lambda c: c[2])]

    return filtered_circles



import numpy as np
from itertools import combinations

def filter_circles_by_distance(circles, min_distance_factor=1, max_distance_factor=3):
    """
    Filter circles based on proximity to each other.

    Parameters:
        circles (list): List of detected circles [(x, y, radius), ...].
        min_distance_factor (float): Minimum distance as a multiple of the average radius.
        max_distance_factor (float): Maximum distance as a multiple of the average radius.

    Returns:
        filtered_circles (list): List of filtered circles.
    """
    if not circles or len(circles) < 3:
        return circles  # Not enough circles to filter

    # Extract coordinates and radii
    coordinates = [(x, y) for x, y, r in circles]
    radii = [r for x, y, r in circles]
    avg_radius = np.mean(radii)

    # Calculate pairwise distances
    valid_circles = []
    for circle in circles:
        x1, y1, r1 = circle
        distances = []
        for x2, y2, r2 in circles:
            if (x1, y1) != (x2, y2):
                distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
                distances.append(distance)
        
        # Check if circle is within the desired distance range
        if all(min_distance_factor * avg_radius <= d <= max_distance_factor * avg_radius for d in distances):
            valid_circles.append(circle)

    return valid_circles[:3]  # Return top 3 circles




import cv2
import numpy as np

def image_process_with_hough_circles(image):
    # Convert to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    
    # Apply CLAHE for contrast enhancement
    clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(4, 4))
    equalized = clahe.apply(gray)
    
    # Apply bilateral filter to reduce noise while preserving edges
    filtered = cv2.bilateralFilter(equalized, 9, 75, 75)
    
    # Apply adaptive threshold for binary segmentation
    thresh = cv2.adaptiveThreshold(
        filtered, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        blockSize=31,
        C=3
    )
    
    # Use HoughCircles to detect circles
    circles = cv2.HoughCircles(
        filtered,  # Input image (smoothed or preprocessed)
        cv2.HOUGH_GRADIENT,  # Detection method
        dp=1.5,  # Inverse ratio of the accumulator resolution to the image resolution
        minDist=20,  # Minimum distance between the centers of detected circles
        param1=50,  # Upper threshold for the internal Canny edge detector
        param2=30,  # Accumulator threshold for circle detection
        minRadius=15,  # Minimum radius of circles to detect
        maxRadius=60  # Maximum radius of circles to detect
    )
    
    # If circles are detected, round and cast them to integers
    detected_circles = []
    if circles is not None:
        circles = np.uint16(np.around(circles))
        for (x, y, radius) in circles[0, :]:
            detected_circles.append((x, y, radius))
    
    return detected_circles

# Example usage
image = cv2.imread('your_image_path.jpg')  # Replace with your image path
detected_circles = image_process_with_hough_circles(image)

# Draw the detected circles on the image
output_image = image.copy()
for (x, y, radius) in detected_circles:
    cv2.circle(output_image, (x, y), radius, (0, 255, 0), 2)
    cv2.circle(output_image, (x, y), 2, (0, 0, 255), 3)  # Center of the circle

# Display the result
cv2.imshow("Detected Circles", output_image)
cv2.waitKey(0)
cv2.destroyAllWindows()









def manual_correction(image_paths, detected_circles_dict, ground_truth_file):
    """
    Allows manual correction of circles for a batch of images.
    Shows one image at a time to avoid opening all at once.
    """
    def draw_circles(image, circles, color):
        for x, y, r in circles:
            cv2.circle(image, (int(x), int(y)), int(r), color, 2)
            cv2.circle(image, (int(x), int(y)), 3, (0, 0, 255), -1)

    def click_event(event, x, y, flags, param):
        nonlocal corrected_circles, image_copy
        if event == cv2.EVENT_LBUTTONDOWN:  # Add a circle
            avg_radius = int(np.mean([r for _, _, r in corrected_circles])) if corrected_circles else 20
            corrected_circles.append((x, y, avg_radius))
            print(f"Circle added at ({x}, {y}) with radius {avg_radius}")
            image_copy = resized_image.copy()
            draw_circles(image_copy, corrected_circles, (0, 255, 0))

        elif event == cv2.EVENT_RBUTTONDOWN:  # Remove a circle
            for i, (cx, cy, cr) in enumerate(corrected_circles):
                distance = np.sqrt((cx - x)**2 + (cy - y)**2)
                if distance <= cr:
                    print(f"Circle removed at ({cx}, {cy})")
                    corrected_circles.pop(i)
                    break
            image_copy = resized_image.copy()
            draw_circles(image_copy, corrected_circles, (0, 255, 0))

    # Load or initialize ground truth
    ground_truth_data = load_or_initialize_ground_truth(ground_truth_file)

    for image_path in image_paths:
        # Load the image
        image = cv2.imread(image_path)
        detected_circles = detected_circles_dict.get(os.path.basename(image_path), [])

        corrected_circles = detected_circles.copy()

        # Resize the image for better display
        max_width, max_height = 800, 800  # Set desired window size
        height, width = image.shape[:2]
        scale = min(max_width / width, max_height / height)
        resized_image = cv2.resize(image, (int(width * scale), int(height * scale)))

        image_copy = resized_image.copy()
        draw_circles(image_copy, detected_circles, (0, 255, 0))

        print(f"Processing {os.path.basename(image_path)}")
        print("Left click to add a circle, right click to remove a circle.")

        cv2.imshow("Manual Circle Correction", image_copy)
        cv2.setMouseCallback("Manual Circle Correction", click_event)

        while True:
            cv2.imshow("Manual Circle Correction", image_copy)
            key = cv2.waitKey(1) & 0xFF
            if key == 27:  # Press 'ESC' to save and move to the next image
                break

        cv2.destroyAllWindows()

        # Save corrected circles for this image
        ground_truth_data = [entry for entry in ground_truth_data if entry["file_name"] != os.path.basename(image_path)]
        ground_truth_data.append({"file_name": os.path.basename(image_path), "circles": corrected_circles})

    # Save the final ground truth after processing all images
    save_ground_truth(ground_truth_file, ground_truth_data)
    print("Ground truth updated for all processed images.")







import cv2
import numpy as np
import json
import os

# Circle detection function using contours
def detect_circles(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:  # Adjust thresholds as needed
                detected_circles.append((int(x), int(y), int(radius)))
    return detected_circles

# Load or initialize ground truth
def load_or_initialize_ground_truth(file_path):
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            return json.load(f)
    else:
        return []

# Save ground truth to file
def save_ground_truth(file_path, data):
    with open(file_path, "w") as f:
        json.dump(data, f, indent=4)

# Interactive correction of detected circles
def manual_correction(image_path, detected_circles, ground_truth_file):
    image = cv2.imread(image_path)
    corrected_circles = detected_circles.copy()

    def draw_circles(image, circles, color):
        for x, y, r in circles:
            cv2.circle(image, (int(x), int(y)), int(r), color, 2)
            cv2.circle(image, (int(x), int(y)), 3, (0, 0, 255), -1)

    def click_event(event, x, y, flags, param):
        nonlocal corrected_circles, image_copy
        if event == cv2.EVENT_LBUTTONDOWN:  # Add a circle
            avg_radius = int(np.mean([r for _, _, r in corrected_circles])) if corrected_circles else 20
            corrected_circles.append((x, y, avg_radius))
            print(f"Circle added at ({x}, {y}) with radius {avg_radius}")
            image_copy = image.copy()
            draw_circles(image_copy, corrected_circles, (0, 255, 0))

        elif event == cv2.EVENT_RBUTTONDOWN:  # Remove a circle
            for i, (cx, cy, cr) in enumerate(corrected_circles):
                distance = np.sqrt((cx - x)**2 + (cy - y)**2)
                if distance <= cr:
                    print(f"Circle removed at ({cx}, {cy})")
                    corrected_circles.pop(i)
                    break
            image_copy = image.copy()
            draw_circles(image_copy, corrected_circles, (0, 255, 0))

    image_copy = image.copy()
    draw_circles(image_copy, detected_circles, (0, 255, 0))
    print("Left click to add a circle, right click to remove a circle.")
    cv2.imshow("Manual Circle Correction", image_copy)
    cv2.setMouseCallback("Manual Circle Correction", click_event)

    while True:
        cv2.imshow("Manual Circle Correction", image_copy)
        key = cv2.waitKey(1) & 0xFF
        if key == 27:  # Press 'ESC' to save and exit
            break

    cv2.destroyAllWindows()

    # Save corrected circles
    file_name = os.path.basename(image_path)
    ground_truth_data = load_or_initialize_ground_truth(ground_truth_file)
    ground_truth_data = [entry for entry in ground_truth_data if entry["file_name"] != file_name]
    ground_truth_data.append({"file_name": file_name, "circles": corrected_circles})
    save_ground_truth(ground_truth_file, ground_truth_data)
    print(f"Corrected circles saved for {file_name}.")

# Main loop for processing images
def process_images(folder_path, ground_truth_file):
    images = [f for f in os.listdir(folder_path) if f.endswith(('.png', '.jpg', '.jpeg'))]
    for image_name in images:
        image_path = os.path.join(folder_path, image_name)
        print(f"Processing {image_name}...")
        image = cv2.imread(image_path)
        detected_circles = detect_circles(image)
        print(f"Detected circles: {detected_circles}")
        manual_correction(image_path, detected_circles, ground_truth_file)

# Example usage
if __name__ == "__main__":
    image_folder = "path_to_your_image_folder"
    ground_truth_file = "ground_truth.json"
    process_images(image_folder, ground_truth_file)


















def filter_circles_flexible_alignment(circles, max_distance_factor=3):
    """
    Filters circles based on the distance between them and adjusts for horizontal, vertical, or diagonal alignment.
    :param circles: List of detected circles [(x, y, radius)].
    :param max_distance_factor: Maximum allowed distance between circles relative to their radii.
    :return: Filtered list of circles.
    """
    if len(circles) <= 1:
        return circles  # If only one or no circles, return as is.

    # Calculate the average radius of all detected circles
    avg_radius = np.mean([c[2] for c in circles])

    # Determine alignment (horizontal, vertical, or diagonal)
    # Calculate the average differences in x and y coordinates
    x_diffs = [abs(circles[i][0] - circles[i - 1][0]) for i in range(1, len(circles))]
    y_diffs = [abs(circles[i][1] - circles[i - 1][1]) for i in range(1, len(circles))]
    avg_x_diff = np.mean(x_diffs) if x_diffs else 0
    avg_y_diff = np.mean(y_diffs) if y_diffs else 0

    # Sort based on dominant alignment
    if avg_x_diff > avg_y_diff:
        circles = sorted(circles, key=lambda c: c[0])  # Horizontal alignment
    else:
        circles = sorted(circles, key=lambda c: c[1])  # Vertical alignment

    filtered_circles = [circles[0]]  # Start with the first circle
    for i in range(1, len(circles)):
        x1, y1, r1 = filtered_circles[-1]
        x2, y2, r2 = circles[i]

        # Calculate the distance between the centers of two circles
        distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

        # Debug: Print distance and average radius
        print(f"Distance between Circle {i} and Circle {i-1}: {distance:.2f}")
        print(f"Average Radius: {avg_radius:.2f}")

        # Keep the circle if the distance is within an acceptable range
        if distance <= max_distance_factor * avg_radius:
            filtered_circles.append(circles[i])

    # Debug: Show circles after filtering
    print(f"Filtered Circles: {filtered_circles}")

    # If fewer than 3 circles remain, return as many as possible
    return filtered_circles[:3]




def filter_circles_by_proximity_v2(circles):
    """
    Improved circle filtering based on proximity with dynamic thresholds.
    :param circles: List of detected circles [(x, y, radius)].
    :return: Filtered list of circles.
    """
    if len(circles) <= 1:
        return circles  # If only one or no circles, return as is.

    # Sort circles by their vertical alignment (y-coordinate), then x-coordinate
    circles = sorted(circles, key=lambda c: (c[1], c[0]))

    # Compute median radius for dynamic threshold
    radii = [c[2] for c in circles]
    median_radius = np.median(radii)
    distance_threshold = 3 * median_radius  # Threshold based on median radius

    # Initialize filtered list with the first circle
    filtered_circles = [circles[0]]
    for i in range(1, len(circles)):
        x1, y1, _ = filtered_circles[-1]
        x2, y2, _ = circles[i]

        # Calculate Euclidean distance between current circle and the previous valid circle
        distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        if distance <= distance_threshold:
            filtered_circles.append(circles[i])

    # Keep only the closest 3 circles if more than 3 are detected
    if len(filtered_circles) > 3:
        filtered_circles = filtered_circles[:3]

    return filtered_circles




def filter_circles_by_proximity(circles):
    """
    Filter circles based on their proximity to each other.
    :param circles: List of detected circles [(x, y, radius)].
    :return: Filtered list of circles.
    """
    if len(circles) == 0:
        return []

    if len(circles) == 1:
        return circles  # Only one circle detected; use it as is.

    # Sort circles by their x-coordinates (horizontal alignment)
    circles = sorted(circles, key=lambda c: (c[1], c[0]))  # Sort by y (vertical), then x

    # Establish a maximum distance threshold (3 * the largest radius)
    max_radius = max([c[2] for c in circles])
    distance_threshold = 3 * max_radius

    # Start with the first circle and find the closest valid circles
    valid_circles = [circles[0]]
    for i in range(1, len(circles)):
        x1, y1, _ = valid_circles[-1]
        x2, y2, _ = circles[i]

        # Compute the Euclidean distance
        distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        if distance <= distance_threshold:
            valid_circles.append(circles[i])

    # If more than 3 circles remain, pick the closest 3
    if len(valid_circles) > 3:
        valid_circles = valid_circles[:3]

    return valid_circles



def filter_circles(detected_circles, max_distance_factor=3):
    """
    Filters detected circles based on their distances.
    - detected_circles: List of tuples (x, y, r).
    - max_distance_factor: Maximum allowable distance as a multiple of diameter.
    """
    if len(detected_circles) < 3:
        # Fallback: If fewer than 3 circles, return what is available
        return detected_circles

    # Sort circles by radius (largest first for consistency)
    detected_circles = sorted(detected_circles, key=lambda c: c[2], reverse=True)

    valid_circles = []
    max_radius = detected_circles[0][2]  # Use the largest radius
    max_distance = max_distance_factor * (2 * max_radius)

    for i in range(len(detected_circles)):
        valid_set = [detected_circles[i]]
        for j in range(i + 1, len(detected_circles)):
            dist = np.sqrt(
                (detected_circles[i][0] - detected_circles[j][0]) ** 2
                + (detected_circles[i][1] - detected_circles[j][1]) ** 2
            )
            if dist <= max_distance:
                valid_set.append(detected_circles[j])

        # Keep the largest valid set of circles
        if len(valid_set) >= 3:
            return valid_set[:3]  # Return the first 3 valid circles

        # Fallback: If fewer than 3 circles are valid, keep the largest set
        if len(valid_circles) < len(valid_set):
            valid_circles = valid_set

    return valid_circles if len(valid_circles) > 0 else [detected_circles[0]]




import numpy as np

def filter_circles_by_distance(circles, distance_factor=3):
    """
    Filters circles based on the distance between their centers.
    - circles: List of tuples (x, y, r) from detection.
    - distance_factor: The maximum allowable distance between centers
                       as a multiple of the diameter of the largest circle.
    """
    if len(circles) < 3:
        # If less than 3 circles, return the largest one (fallback).
        return [max(circles, key=lambda c: c[2])] if circles else []

    # Sort circles by radius (descending) to prioritize the largest one
    circles = sorted(circles, key=lambda c: c[2], reverse=True)

    # Use the largest circle's diameter as the reference
    largest_diameter = circles[0][2] * 2
    max_distance = distance_factor * largest_diameter

    # Filter circles based on the distance between their centers
    filtered_circles = [circles[0]]  # Always keep the largest circle
    for circle in circles[1:]:
        keep_circle = True
        for existing_circle in filtered_circles:
            distance = np.sqrt(
                (circle[0] - existing_circle[0]) ** 2 + (circle[1] - existing_circle[1]) ** 2
            )
            if distance > max_distance:
                keep_circle = False
                break
        if keep_circle:
            filtered_circles.append(circle)

    # If after filtering we still have more than 3 circles, take the closest 3
    if len(filtered_circles) > 3:
        filtered_circles = sorted(filtered_circles, key=lambda c: c[1])[:3]

    return filtered_circles








def filter_circles(circles, max_distance_factor=1.5, size_similarity_threshold=0.2):
    """
    Filters detected circles to identify valid ones for the line and measurement calculations.
    - circles: List of tuples (x, y, r) from detection.
    - max_distance_factor: Maximum distance between circles relative to their radius.
    - size_similarity_threshold: Threshold for size (radius) similarity.
    """
    if len(circles) < 3:
        # If less than 3 circles, return them as is (or just the first one).
        return circles[:1]  # Return one circle for fallback
    
    # Sort circles by their x-coordinate (horizontal alignment assumption).
    circles = sorted(circles, key=lambda c: c[0])
    
    valid_circles = []
    for i, (x1, y1, r1) in enumerate(circles):
        group = [(x1, y1, r1)]
        for j, (x2, y2, r2) in enumerate(circles[i + 1:], start=i + 1):
            distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
            
            # Check if the circles are close enough and similar in size
            if (
                distance <= max_distance_factor * r1
                and abs(r2 - r1) / max(r1, r2) <= size_similarity_threshold
            ):
                group.append((x2, y2, r2))
            
            # Stop if we already have 3 valid circles
            if len(group) == 3:
                break
        
        # If a valid group of 3 is found, add it to the results
        if len(group) == 3:
            valid_circles = group
            break
    
    # If no valid group of 3 is found, return the closest 3
    if not valid_circles and len(circles) >= 3:
        valid_circles = circles[:3]
    
    # If still no valid circles (edge case), return just the largest one
    if not valid_circles:
        valid_circles = [max(circles, key=lambda c: c[2])]  # Return the largest circle

    return valid_circles




def filter_circles_based_on_distance(circles, max_distance_ratio=3.0):
    """
    Filters circles based on distances between them. If one circle is too far, fallback to two circles or just one.
    - circles: List of detected circles [(x, y, radius)].
    - max_distance_ratio: Maximum allowed distance between circles as a multiple of the average radius.
    """
    if len(circles) < 2:
        return circles  # Not enough circles to filter

    # Calculate average radius
    radii = [circle[2] for circle in circles]
    avg_radius = np.mean(radii)

    # Calculate pairwise distances
    distances = []
    for i in range(len(circles)):
        for j in range(i + 1, len(circles)):
            dist = np.sqrt(
                (circles[i][0] - circles[j][0]) ** 2 +
                (circles[i][1] - circles[j][1]) ** 2
            )
            distances.append((dist, i, j))

    # Filter out pairs with distances exceeding the threshold
    valid_pairs = [
        (dist, i, j) for dist, i, j in distances if dist <= max_distance_ratio * avg_radius
    ]

    # Identify valid circles based on pairs
    valid_indices = set()
    for _, i, j in valid_pairs:
        valid_indices.add(i)
        valid_indices.add(j)

    # Fallback logic
    if len(valid_indices) >= 3:
        # If 3 or more circles are valid, keep the closest 3
        sorted_circles = sorted(valid_indices, key=lambda idx: radii[idx], reverse=True)
        return [circles[idx] for idx in sorted_circles[:3]]
    elif len(valid_indices) == 2:
        # If only 2 circles are valid, return them
        return [circles[idx] for idx in valid_indices]
    elif len(valid_indices) == 1:
        # If only 1 circle is valid, return it
        return [circles[next(iter(valid_indices))]]
    else:
        # If no valid circles, return the first detected circle as fallback
        return [circles[0]] if circles else []

mmm




import numpy as np
import cv2

def filter_circles_alignment_agnostic(circles, max_distance_ratio=3.0, size_tolerance=0.5):
    """
    Filters circles based on size and proximity, agnostic to alignment (horizontal, vertical, or diagonal).
    - circles: List of tuples [(x, y, radius)].
    - max_distance_ratio: Max allowed distance between circles relative to their average radius.
    - size_tolerance: Tolerance for radius variation (fraction of the average radius).
    """
    if len(circles) < 2:
        return circles

    # Calculate average radius
    radii = [circle[2] for circle in circles]
    avg_radius = np.mean(radii)

    # Filter by size consistency
    filtered_circles = [
        circle for circle in circles
        if (1 - size_tolerance) * avg_radius <= circle[2] <= (1 + size_tolerance) * avg_radius
    ]

    if len(filtered_circles) < 2:
        return filtered_circles[:2]  # Ensure at least two circles for distance calculation

    # Calculate distances between all pairs of circles
    distances = []
    for i in range(len(filtered_circles)):
        for j in range(i + 1, len(filtered_circles)):
            dist = np.sqrt(
                (filtered_circles[i][0] - filtered_circles[j][0]) ** 2 +
                (filtered_circles[i][1] - filtered_circles[j][1]) ** 2
            )
            distances.append((dist, i, j))

    # Sort distances and keep the closest pairs
    distances = sorted(distances, key=lambda x: x[0])
    selected_indices = set()
    for dist, i, j in distances:
        if dist <= max_distance_ratio * avg_radius:
            selected_indices.add(i)
            selected_indices.add(j)

    # Return up to 3 circles based on proximity and alignment
    return [filtered_circles[idx] for idx in sorted(selected_indices)[:3]]


def process_image_with_dynamic_filtering(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.6 < circularity < 1.4 and 5 < radius < 50:  # Adjust thresholds as needed
                detected_circles.append((int(x), int(y), int(radius)))

    # Apply alignment-agnostic filtering
    filtered_circles = filter_circles_alignment_agnostic(detected_circles)

    # Draw circles and lines
    processed_image = image.copy()
    line_coords = None

    if len(filtered_circles) >= 2:
        cv2.line(
            processed_image,
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
            (255, 0, 0), 3
        )
        line_coords = (
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
        )

    for (x, y, r) in filtered_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 3)  # Thicker circle
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, filtered_circles, line_coords








import numpy as np

def filter_circles_by_size_and_proximity(circles, max_distance_ratio=2.0, size_tolerance=0.5):
    """
    Filters circles based on size and proximity.
    - circles: List of tuples [(x, y, radius)].
    - max_distance_ratio: Max allowed distance between circles relative to their average radius.
    - size_tolerance: Tolerance for radius variation (fraction of the average radius).
    """
    if len(circles) < 2:
        return circles

    # Calculate average radius
    radii = [circle[2] for circle in circles]
    avg_radius = np.mean(radii)

    # Filter by size consistency
    filtered_circles = [
        circle for circle in circles
        if (1 - size_tolerance) * avg_radius <= circle[2] <= (1 + size_tolerance) * avg_radius
    ]

    # If fewer than 2 circles remain, fallback to one circle
    if len(filtered_circles) < 2:
        return filtered_circles[:1]

    # Filter by proximity
    result_circles = []
    for i in range(len(filtered_circles)):
        for j in range(i + 1, len(filtered_circles)):
            dist = np.sqrt(
                (filtered_circles[i][0] - filtered_circles[j][0]) ** 2 +
                (filtered_circles[i][1] - filtered_circles[j][1]) ** 2
            )
            # Include pairs that are close enough
            if dist <= max_distance_ratio * avg_radius:
                result_circles.append(filtered_circles[i])
                result_circles.append(filtered_circles[j])

    # Remove duplicates and limit to 3 closest circles
    result_circles = list(set(result_circles))
    result_circles = sorted(result_circles, key=lambda c: c[0])[:3]  # Sort by x-coordinate

    return result_circles


def process_image_with_filters(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.6 < circularity < 1.4 and 5 < radius < 50:  # Adjust thresholds as needed
                detected_circles.append((int(x), int(y), int(radius)))

    # Filter circles by size and proximity
    filtered_circles = filter_circles_by_size_and_proximity(detected_circles)

    # Draw circles and lines
    processed_image = image.copy()
    line_coords = None

    if len(filtered_circles) >= 2:
        cv2.line(
            processed_image,
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
            (255, 0, 0), 3
        )
        line_coords = (
            (filtered_circles[0][0] - filtered_circles[0][2], filtered_circles[0][1]),
            (filtered_circles[1][0] + filtered_circles[1][2], filtered_circles[1][1]),
        )

    for (x, y, r) in filtered_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 3)  # Thicker circle
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, filtered_circles, line_coords













def draw_bounding_boxes_on_image(image, boxes):
    """
    Draw bounding boxes with labels (bounding box number) on the image.
    
    :param image: The image to draw on.
    :param boxes: YOLO bounding boxes.
    """
    processed_image = image.copy()

    for idx, box in enumerate(boxes.xyxy.tolist(), start=1):
        # Extract bounding box coordinates
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]

        # Draw bounding box with thicker line
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), thickness=3)

        # Create label for the bounding box
        label = f"Box {idx}"

        # Add a background rectangle for the label
        text_size, baseline = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)
        text_width, text_height = text_size
        cv2.rectangle(processed_image, (x1, y1 - text_height - 5), (x1 + text_width, y1), (0, 255, 255), -1)

        # Put the label on the background rectangle
        cv2.putText(
            processed_image, label, (x1, y1 - 5),
            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), thickness=1, lineType=cv2.LINE_AA
        )

    return processed_image








def draw_bounding_boxes_on_image(image, boxes, pixel_to_mm_ratio):
    processed_image = image.copy()
    for idx, box in enumerate(boxes.xyxy.tolist(), start=1):
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), thickness=4)  # Thicker bounding box
        label = f"BB{idx}"  # Add the bounding box number
        cv2.putText(
            processed_image, label, (x1, y1 - 10),
            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), thickness=2
        )
    return processed_image





import streamlit as st
import cv2
import numpy as np
from PIL import Image

def process_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:
                detected_circles.append((int(x), int(y), int(radius)))

    detected_circles = sorted(detected_circles, key=lambda c: c[1])  # Sort by y-coordinate
    processed_image = image.copy()
    line_coords = None

    if len(detected_circles) >= 3:
        x1, y1, r1 = detected_circles[0]
        x3, y3, r3 = detected_circles[2]
        cv2.line(processed_image, (x1, y1 - r1), (x3, y3 - r3), (255, 0, 0), 2)
        line_coords = ((x1, y1 - r1), (x3, y3 - r3))
    elif len(detected_circles) == 2 or len(detected_circles) == 1:
        x, y, r = detected_circles[0]
        cv2.line(processed_image, (x, y - r), (x, y + r), (255, 0, 0), 2)
        line_coords = ((x, y - r), (x, y + r))
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, detected_circles, line_coords

def calculate_pixel_to_mm_ratio(detected_circles, line_coords):
    if len(detected_circles) >= 3 and line_coords:
        (x1, y1), (x2, y2) = line_coords
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        known_distance_mm = 10  # Known distance for 3 circles
        return known_distance_mm / pixel_distance
    elif len(detected_circles) >= 1:
        radius = detected_circles[0][2]
        return 2 / (2 * radius)  # Convert diameter in pixels
    else:
        return None

def draw_bounding_boxes_on_image(image, boxes):
    processed_image = image.copy()
    for box in boxes.xyxy.tolist():
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
    return processed_image

def get_image_prediction(image_obj, yolo, file=None):
    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes

        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        processed_img_with_boxes = draw_bounding_boxes_on_image(processed_image, pred_boxes)
        st.image(processed_img_with_boxes, caption="Processed Image with Circles, Line, and Bounding Boxes")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        if pixel_to_mm_ratio is not None:
            for i, box in enumerate(pred_boxes.xyxy.tolist(), start=1):
                x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
                width_px = x2 - x1
                height_px = y2 - y1
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Box {i}: Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
        else:
            st.write("Unable to calculate measurements (missing circles).")

def main():
    st.title("Image Processing with YOLO and Circle Detection")
    uploaded_file = st.file_uploader("Upload an image", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        image_obj = Image.open(uploaded_file)
        yolo = ...  # Load your YOLO model here
        get_image_prediction(image_obj, yolo, file=uploaded_file)

if __name__ == "__main__":
    main()













def draw_bounding_boxes_on_image(image, boxes):
    processed_image = image.copy()

    for i, box in enumerate(boxes.xyxy.tolist(), start=1):
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        # Draw bounding box with a thicker line
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)

    return processed_image

def get_image_prediction(image_obj, yolo, file=None):
    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes

        # Process the image to detect circles and draw line
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes on the processed image
        processed_img_with_boxes = draw_bounding_boxes_on_image(processed_image, pred_boxes)

        # Show the processed image
        st.image(processed_img_with_boxes, caption="Processed Image with Circles, Line, and Bounding Boxes")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        if pixel_to_mm_ratio is not None:
            for i, box in enumerate(pred_boxes.xyxy.tolist(), start=1):
                x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
                width_px = x2 - x1
                height_px = y2 - y1
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Box {i}: Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
        else:
            st.write("Unable to calculate measurements (missing circles).")












import cv2
import numpy as np
import streamlit as st
from PIL import Image


def process_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    _, thresh = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    detected_circles = []
    for contour in contours:
        ((x, y), radius) = cv2.minEnclosingCircle(contour)
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if perimeter > 0:
            circularity = 4 * np.pi * (area / (perimeter ** 2))
            if 0.7 < circularity < 1.3 and radius > 5:
                detected_circles.append((int(x), int(y), int(radius)))

    detected_circles = sorted(detected_circles, key=lambda c: c[1])
    processed_image = image.copy()
    line_coords = None

    if len(detected_circles) >= 3:
        cv2.line(
            processed_image,
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1]),
            (255, 0, 0), 2
        )
        line_coords = (
            (detected_circles[0][0], detected_circles[0][1]),
            (detected_circles[2][0], detected_circles[2][1])
        )

    for (x, y, r) in detected_circles:
        cv2.circle(processed_image, (x, y), r, (0, 255, 0), 2)
        cv2.circle(processed_image, (x, y), 2, (0, 0, 255), 3)

    return processed_image, detected_circles, line_coords


def calculate_pixel_to_mm_ratio(detected_circles, line_coords):
    if len(detected_circles) >= 3 and line_coords:
        # Use the line created by 3 circles
        (x1, y1), (x2, y2) = line_coords
        pixel_distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        known_distance_mm = 10  # Known distance for 3 circles
        return known_distance_mm / pixel_distance
    elif len(detected_circles) >= 1:
        # Use the diameter of one circle
        radius = detected_circles[0][2]
        return 2 / (2 * radius)  # Convert diameter in pixels
    else:
        return None


def draw_bounding_boxes_on_image(image, boxes, pixel_to_mm_ratio):
    processed_image = image.copy()
    for box in boxes.xyxy.tolist():
        x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
        cv2.rectangle(processed_image, (x1, y1), (x2, y2), (255, 0, 0), 2)
        if pixel_to_mm_ratio:
            width_px = x2 - x1
            height_px = y2 - y1
            width_mm = width_px * pixel_to_mm_ratio
            height_mm = height_px * pixel_to_mm_ratio
            text = f"{width_mm:.2f}mm x {height_mm:.2f}mm"
            cv2.putText(
                processed_image, text, (x1, y1 - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2
            )
    return processed_image


def get_image_prediction(image_obj, yolo, file=None):
    category_list = ["1", "2", "3", "4"]
    pred_df = {}
    if isinstance(file, str):
        pred_df["filename"] = file
    else:
        pred_df["filename"] = file.name

    col1, col2, col3 = st.columns([3, 3, 2], gap="medium")
    with col1:
        st.info("Preview of Raw Image")
        st.image(image_obj)

    with col2:
        st.spinner("Processing image for predictions...")
        image_array = np.array(image_obj)
        results = yolo.predictions(image_array)
        pred_boxes = results[0].boxes
        pixel_to_mm_ratio = None
        pred_img = results[0].plot()

        # Process image for circle detection and line drawing
        processed_image, detected_circles, line_coords = process_image(image_array)
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(detected_circles, line_coords)

        # Draw bounding boxes with measurements in mm
        processed_img_with_boxes = draw_bounding_boxes_on_image(
            processed_image, pred_boxes, pixel_to_mm_ratio
        )
        st.image(processed_img_with_boxes, caption="Processed Image with Predictions")

    with col3:
        st.info("Bounding Box Measurements (mm)")
        for box in pred_boxes.xyxy.tolist():
            x1, y1, x2, y2 = [int(coord) for coord in box[:4]]
            width_px = x2 - x1
            height_px = y2 - y1
            if pixel_to_mm_ratio:
                width_mm = width_px * pixel_to_mm_ratio
                height_mm = height_px * pixel_to_mm_ratio
                st.write(f"Width: {width_mm:.2f} mm, Height: {height_mm:.2f} mm")
            else:
                st.write("Unable to calculate measurements (missing circles).")

import streamlit as st
from PIL import Image
import numpy as np
import cv2


def main():
    st.set_page_config(page_title="Image Predictions with Measurements", page_icon="📏")

    # Sidebar for uploading image
    st.sidebar.header("Upload Image")
    image_obj = None
    file = st.sidebar.file_uploader("Upload an image (PNG or JPG)", type=["png", "jpg", "jpeg"])
    
    if file is not None:
        image_obj = Image.open(file)

    # Sidebar for loading YOLO model
    st.sidebar.header("Model Selection")
    st.sidebar.info("Loading YOLO model for predictions...")
    yolo_model = load_yolo_model()  # Replace with your YOLO model loading logic

    # Layout for the main content
    if image_obj is not None and yolo_model is not None:
        st.subheader("Image Predictions and Measurements")

        # Call the get_image_prediction function
        get_image_prediction(image_obj, yolo_model, file=file)
    else:
        st.warning("Please upload an image to start the prediction.")

    st.sidebar.write("---")
    st.sidebar.info("Developed by [Your Name].")

def load_yolo_model():
    """Loads the YOLO model for predictions."""
    with st.spinner("Loading YOLO model..."):
        # Replace with your model loading logic
        model = model_Pred(
            best_model=r"C:\path\to\model\best.pt", 
            data_yaml="cvde_coco_yolo_sn.yaml"
        )
        st.success("YOLO model loaded successfully!")
    return model


if __name__ == "__main__":
    main()
