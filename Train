
import plotly.express as px
import pandas as pd
import numpy as np

# Build unified dataframe
water_masked_fresh = np.full(len(embedding_fresh), None)   # <── THIS fixes everything

df_plot = pd.DataFrame({
    "UMAP_1": np.concatenate([embedding_fresh[:, 0], embedding_eni[:, 0]]),
    "UMAP_2": np.concatenate([embedding_fresh[:, 1], embedding_eni[:, 1]]),
    "dataset": (["FRESH"] * len(embedding_fresh)) + (["ENI"] * len(embedding_eni)),
    "water_ppm": np.concatenate([
        water_masked_fresh,   # <── FRESH does NOT enter colorscale
        water_ppm_eni         # <── ENI DOES use the colormap
    ])
})

fig = px.scatter(
    df_plot,
    x="UMAP_1",
    y="UMAP_2",
    color="water_ppm",
    symbol="dataset",
    color_continuous_scale="Turbo",
    labels={"color": "water_ppm"},
    width=800,
    height=600,
    title="Combined UMAP — FRESH (gray) + ENI (colored by water)"
)

# Force FRESH to be gray
fig.update_traces(
    selector=dict(marker_symbol="circle"),  # or the symbol px assigns to FRESH
    marker=dict(color="gray")
)

fig.show()







import plotly.express as px
import pandas as pd
import numpy as np

# Combine fresh + eni latents into a single DataFrame
df_plot = pd.DataFrame({
    "UMAP_1": np.concatenate([embedding_fresh[:,0], embedding_eni[:,0]]),
    "UMAP_2": np.concatenate([embedding_fresh[:,1], embedding_eni[:,1]]),
    "dataset": (["FRESH"] * len(embedding_fresh)) + (["ENI"] * len(embedding_eni)),
    "water_ppm": np.concatenate([
        np.zeros(len(embedding_fresh)),   # fresh gets 0 (or NA)
        water_ppm_eni                     # your actual ENI labels
    ])
})

# Scatter: color only ENI by water_ppm, Fresh forced to gray
fig = px.scatter(
    df_plot,
    x="UMAP_1",
    y="UMAP_2",
    color="water_ppm",
    color_continuous_scale="Turbo",
    hover_data=["dataset", "water_ppm"]
)

# Override colors for FRESH → gray
fig.update_traces(
    selector=dict(mode="markers"),
    marker=dict(size=8)
)

# Set FRESH to gray manually
fig.for_each_trace(
    lambda t: t.update(marker_color="gray") if "FRESH" in t.hovertemplate else None
)

fig.update_layout(
    title="Combined UMAP — Fresh (gray) + ENI (colored by water_ppm)",
    coloraxis_colorbar=dict(title="water_ppm")
)

fig.show()







import plotly.graph_objects as go

# embeddings you already computed separately
# embedding_fresh : (N_fresh, 2)
# embedding_eni   : (N_eni, 2)

# labels you already have
# water_ppm_eni = y_tensor_eni.flatten()

fig = go.Figure()

# --- Trace 1: FRESH (gray, not colored by water) ---
fig.add_trace(
    go.Scatter(
        x = embedding_fresh[:, 0],
        y = embedding_fresh[:, 1],
        mode = "markers",
        marker=dict(
            size=8,
            color="lightgray"
        ),
        name="FRESH"
    )
)

# --- Trace 2: ENI (colored by water) ---
fig.add_trace(
    go.Scatter(
        x = embedding_eni[:, 0],
        y = embedding_eni[:, 1],
        mode = "markers",
        marker=dict(
            size=8,
            color = water_ppm_eni,
            colorscale="Turbo",
            showscale=True,
            colorbar=dict(title="water_ppm")
        ),
        text = sweep_aged_eni["sweep_new"],   # optional hover info
        hovertemplate="UMAP1=%{x}<br>UMAP2=%{y}<br>water=%{marker.color}<br>sweep=%{text}",
        name="ENI"
    )
)

fig.update_layout(
    title="UMAP Projection — FRESH (gray) + ENI (colored)",
    xaxis_title="UMAP_1",
    yaxis_title="UMAP_2",
    width=800,
    height=600
)

fig.show()









import umap.umap_ as umap
import pandas as pd
import plotly.express as px
import numpy as np

# -----------------------------
# Combine latent vectors
# -----------------------------
latents_all = np.vstack([latent_features, latent_features_mobil])

# Extract labels as 1D arrays
labels_water = np.concatenate([
    y_fresh.values.flatten(),
    y_eni.values.flatten()
])

# Dataset indicator
labels_dataset = (["FRESH"] * len(latent_features)) + \
                 (["ENI"] * len(latent_features_mobil))

# -----------------------------
# UMAP
# -----------------------------
reducer = umap.UMAP(n_components=2, random_state=42)
embedding = reducer.fit_transform(latents_all)

# -----------------------------
# Build plotting DataFrame
# -----------------------------
df_umap = pd.DataFrame({
    "UMAP_1": embedding[:, 0],
    "UMAP_2": embedding[:, 1],
    "dataset": labels_dataset,
    "water_ppm": labels_water
})

# -----------------------------
# Plot
# -----------------------------
fig = px.scatter(
    df_umap,
    x="UMAP_1",
    y="UMAP_2",
    color="dataset",      # separates Fresh vs ENI
    symbol="dataset",     # adds different markers
    hover_data=["water_ppm"],
    opacity=0.85
)

fig.update_layout(
    title="Combined UMAP — Fresh vs ENI",
    width=800,
    height=600
)

fig.show()









import umap.umap_ as umap
import pandas as pd
import plotly.express as px
import numpy as np

# -----------------------------
# 1. CONCATENAR FRESH + ENI
# -----------------------------
latents_all = np.vstack([latent_features_fresh, latent_features_eni])

labels_water = np.concatenate([y_fresh.flatten(), y_eni.flatten()])
labels_dataset = (["FRESH"] * len(latent_features_fresh)) + \
                 (["ENI"] * len(latent_features_eni))

# -----------------------------
# 2. UMAP COMBINADO
# -----------------------------
reducer = umap.UMAP(n_components=2, random_state=42)
embedding = reducer.fit_transform(latents_all)

# -----------------------------
# 3. DATAFRAME PARA PLOT
# -----------------------------
df_umap = pd.DataFrame({
    "UMAP_1": embedding[:, 0],
    "UMAP_2": embedding[:, 1],
    "dataset": labels_dataset,
    "water_ppm": labels_water
})

# -----------------------------
# 4. SCATTER SEPARANDO DATASET
# -----------------------------
fig = px.scatter(
    df_umap,
    x="UMAP_1",
    y="UMAP_2",
    color="dataset",          # <-- AQUÍ SE SEPARA FRESH VS ENI
    symbol="dataset",         # <-- OPCIONAL: círculos vs triángulos
    hover_data=["water_ppm"], # <-- water solo aparece en hover
    opacity=0.85
)

fig.update_layout(
    title="Combined UMAP — Fresh vs ENI",
    width=700,
    height=600
)

fig.show()










import umap.umap_ as umap
import plotly.express as px
import numpy as np
import pandas as pd

# -------------------------------
# 1. STACK latent vectors together
# -------------------------------
latents_fresh = latent_features_fresh
latents_eni   = latent_features_mobil

latents_all = np.vstack([latents_fresh, latents_eni])

# -------------------------------
# 2. Run UMAP on the combined set
# -------------------------------
reducer = umap.UMAP(n_components=2, random_state=42)
embedding = reducer.fit_transform(latents_all)

# Split back
emb_fresh = embedding[:len(latents_fresh)]
emb_eni   = embedding[len(latents_fresh):]

# -------------------------------
# 3. Build two DataFrames
# -------------------------------
df_fresh = pd.DataFrame({
    "UMAP_1": emb_fresh[:,0],
    "UMAP_2": emb_fresh[:,1],
    "type": "Fresh",
    "water_ppm": 0,
    "sweep_new": sweep_aged_fresh["sweep_new"].values
})

df_eni = pd.DataFrame({
    "UMAP_1": emb_eni[:,0],
    "UMAP_2": emb_eni[:,1],
    "type": "ENI",
    "water_ppm": y_tensor_eni.flatten(),    # tus labels originales
    "sweep_new": sweep_aged_eni["sweep_new"].values
})

# Combine for hover
df_umap = pd.concat([df_fresh, df_eni], ignore_index=True)

# -------------------------------
# 4. Make the PLOT
# -------------------------------
fig = px.scatter(
    df_umap,
    x="UMAP_1",
    y="UMAP_2",
    color="water_ppm",
    hover_data=["sweep_new", "type"],
    title="Combined UMAP — Fresh + ENI",
)

# Override FRESH color to fixed gray
fig.for_each_trace(
    lambda trace: trace.update(marker=dict(color="lightgray"))
    if trace.name == "0" else None  # Fresh has water_ppm = 0
)

fig.update_traces(marker=dict(size=9))
fig.update_layout(width=700, height=600)

fig.show()










df_results_val["TAN"] = pd.to_numeric(df_results_val["TAN"], errors="coerce")


import seaborn as sns
import pandas as pd

# Get folds only
fold_cols = [col for col in cv_results.columns if 'split' in col and 'test_score' in col]
folds_df = cv_results[fold_cols].copy()
folds_df = -folds_df  # Convert neg_MSE to positive MSE
folds_df.columns = [col.replace('_test_score', '') for col in folds_df.columns]
folds_df.index = [f'Model {i+1}' for i in range(len(folds_df))]

plt.figure(figsize=(10, 6))
sns.heatmap(folds_df, annot=True, fmt=".5f", cmap="YlGnBu", cbar_kws={'label': 'MSE'})
plt.title("MSE per Fold for Each Model (Cross-Validation)")
plt.xlabel("Fold")
plt.ylabel("Model")
plt.tight_layout()
plt.show()




import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.errorbar(
    range(len(sorted_results)),
    -sorted_results['mean_test_score'],  # Mean MSE
    yerr=sorted_results['std_test_score'],  # STD MSE
    fmt='o',
    capsize=5,
    ecolor='gray',
    label='Mean MSE ± STD (CV)'
)

plt.xticks(
    range(len(sorted_results)),
    [f"Model {i+1}" for i in range(len(sorted_results))],
    rotation=45
)

plt.title('Cross-validation MSE by Hyperparameter Combination')
plt.ylabel('Mean Squared Error')
plt.xlabel('Hyperparameter Combinations')
plt.grid(True)
plt.tight_layout()
plt.legend()
plt.show()





best_row = sorted_results.iloc[0]
print("Best Model Parameters:")
print(best_row['params'])
print(f"Mean MSE: {-best_row['mean_test_score']:.5f}")
print(f"STD: {best_row['std_test_score']:.5f}")




import matplotlib.pyplot as plt

# Sort results by mean_test_score (descending)
sorted_results = cv_results.sort_values('mean_test_score', ascending=False).reset_index(drop=True)

# Create plot
plt.figure(figsize=(10, 6))
plt.errorbar(
    range(len(sorted_results)),
    -sorted_results['mean_test_score'],  # negate because it's neg MSE
    yerr=sorted_results['std_test_score'],
    fmt='o',
    ecolor='gray',
    capsize=5,
    label='Cross-validation MSE'
)

# Add labels
plt.title('Cross-Validation Results for GPR Hyperparameter Search')
plt.xlabel('Hyperparameter Combination (sorted by performance)')
plt.ylabel('Mean Squared Error (lower is better)')
plt.xticks(range(len(sorted_results)), labels=[f'Model {i+1}' for i in range(len(sorted_results))], rotation=45)
plt.grid(True)
plt.tight_layout()
plt.legend()
plt.show()






from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense, Lambda
import tensorflow as tf

# Define the input shape for the features (excluding oil labels)
input_shape = X_oil1_train.shape[1]  # Number of features

# Input layer for the features (excluding oil label)
feature_input = Input(shape=(input_shape,))

# Input for the oil label (this is a single value, so the shape is (1,))
oil_label_input = Input(shape=(1,))

# Shared layers for feature extraction from the features
shared_layer = Dense(128, activation='relu')(feature_input)
shared_layer = Dense(64, activation='relu')(shared_layer)

# Task-specific outputs based on the oil label
output1 = Dense(1, activation='linear', name='oil_1_output')(shared_layer)
output2 = Dense(1, activation='linear', name='oil_2_output')(shared_layer)
output3 = Dense(1, activation='linear', name='oil_3_output')(shared_layer)

# Custom function to choose the correct output based on the oil label
def choose_output(inputs):
    oil_label, output1, output2, output3 = inputs
    return tf.where(tf.equal(oil_label, 0), output1, 
           tf.where(tf.equal(oil_label, 1), output2, output3))

# Apply the oil label to select the correct output
chosen_output = Lambda(choose_output)([oil_label_input, output1, output2, output3])

# Define the model
model = Model(inputs=[feature_input, oil_label_input], outputs=chosen_output)

# Compile the model
model.compile(optimizer='adam', loss='mse', metrics=['mae'])

# Summary of the model
model.summary()



# Combine training data (features and labels)
X_comb_train = np.vstack((X_oil1_train, X_oil2_train, X_oil3_train))
y_comb_train = np.hstack((y_oil1_train, y_oil2_train, y_oil3_train))

# Create oil labels (0 for oil1, 1 for oil2, 2 for oil3)
oil_labels_train = np.array([0] * len(X_oil1_train) + [1] * len(X_oil2_train) + [2] * len(X_oil3_train))

# Train the model
history = model.fit(
    [X_comb_train, oil_labels_train],  # Features and oil labels as input
    y_comb_train,  # Combined labels
    epochs=50,
    batch_size=32,
    validation_data=([X_comb_val, oil_labels_val], y_comb_val)  # Combined validation data
)


