# Call the get_image_prediction_circles function to extract predictions
pred_df, pred_classes, pred_conf, results = get_image_prediction_circles(
    image_array, yolo, final_circles, file
)

# Cache predictions in session state
st.session_state['processed_images'][file_name].update({
    "pred_df": pred_df,
    "pred_classes": pred_classes,
    "pred_conf": pred_conf,
    "results": results,  # Cache the results for plotting
})

# Check if we need to update the rendered image
if final_circles != detected_circles or "final_rendered_image" not in processed_data:
    # Render the image with the current circles and predictions
    final_rendered_image = plot_boxes_circles(results, final_circles)
    
    # Update session state with the new rendered image
    st.session_state['processed_images'][file_name]['final_rendered_image'] = final_rendered_image
else:
    # Use cached rendered image
    final_rendered_image = st.session_state['processed_images'][file_name]['final_rendered_image']

# Display the final rendered image
st.image(final_rendered_image, caption="Final Rendered Image with Circles and Bboxes")





def interactive_circle_editor(image_array, circles, circle_colors, key="interactive_canvas"):
    """
    Interactive editor for circles using Streamlit's canvas with color references.

    Parameters:
    - image_array: np.array of the base image.
    - circles: List of detected circles [(x, y, r), ...].
    - circle_colors: List of colors corresponding to each circle.
    - key: Unique key for the Streamlit canvas.

    Returns:
    - updated_circles: List of circles after editing.
    - updated_colors: List of colors after editing.
    """
    from streamlit_drawable_canvas import st_canvas
    import cv2
    import pandas as pd

    # Step 1: Create a reference DataFrame for circles
    circle_reference_list = [
        {"Index": i, "Color": color, "Position": (x, y, r)}
        for i, ((x, y, r), color) in enumerate(zip(circles, circle_colors))
    ]
    circle_reference_df = pd.DataFrame(circle_reference_list)

    # Step 2: Render the canvas with colored circles
    img_with_circles = image_array.copy()
    for (x, y, r), color in zip(circles, circle_colors):
        color_bgr = tuple(map(int, color[4:-1].split(",")[::-1]))
        cv2.circle(img_with_circles, (int(x), int(y)), int(r), color_bgr, thickness=2)

    canvas_result = st_canvas(
        background_image=Image.fromarray(img_with_circles),
        update_streamlit=True,
        height=img_with_circles.shape[0],
        width=img_with_circles.shape[1],
        drawing_mode="circle",  # Allow only circle drawing
        stroke_width=2,
        stroke_color="red",
        key=key,
    )

    # Step 3: Display the circle reference DataFrame
    st.write("Circle Reference List")
    st.dataframe(circle_reference_df)

    # Step 4: Multi-select for removing circles
    dropdown_options = [
        f"Circle {ref['Index']} - Color: {ref['Color']}" for ref in circle_reference_list
    ]
    selected_options = st.multiselect(
        "Select Circles to Remove (by Index and Color):",
        options=dropdown_options,
    )

    # Step 5: Remove selected circles
    selected_indices = [
        int(option.split(" ")[1]) for option in selected_options
    ]  # Extract indices from the dropdown
    updated_circles = [circle for i, circle in enumerate(circles) if i not in selected_indices]
    updated_colors = [color for i, color in enumerate(circle_colors) if i not in selected_indices]

    # Step 6: Add new circles from canvas
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                cx, cy, rx = obj["left"], obj["top"], obj["radius"]
                new_circle = (cx + rx, cy + rx, rx)
                updated_circles.append(new_circle)
                updated_colors.append("rgb(255, 255, 0)")  # Assign a default yellow color for new circles

    return updated_circles, updated_colors



import streamlit as st
import numpy as np
from PIL import Image
from your_module import (
    get_image_predictions,              # Function to predict without circles
    get_image_prediction_circles,      # Function to predict with drawn circles
    interactive_circle_editor,          # Circle editing on canvas
    calculate_pixel_to_mm_ratio,        # Pixel-to-mm ratio calculation
    bbox_results_measurements,          # Bounding box measurements
)

# Ensure session state is initialized
if "processed_images" not in st.session_state:
    st.session_state["processed_images"] = {}

def main():
    # File uploader
    file_uploaded = st.file_uploader(
        "Upload Images", accept_multiple_files=True, type=["jpg", "png"]
    )

    if not file_uploaded:
        st.info("Please upload images to start.")
        return

    # Iterate through uploaded files
    for idx, file in enumerate(file_uploaded):
        file_name = file.name

        # Initialize session state for this image
        if file_name not in st.session_state["processed_images"]:
            image_array = np.array(Image.open(file))
            pred_df, pred_img_obj, boxes = get_image_predictions(image_array, yolo, file_name)
            st.session_state["processed_images"][file_name] = {
                "image_array": image_array,
                "predictions": pred_df,
                "pred_img_obj": pred_img_obj,
                "boxes": boxes,
                "final_circles": None,
                "pixel_to_mm_ratio": None,
                "final_rendered_image": None,
            }

        # Retrieve stored data
        image_data = st.session_state["processed_images"][file_name]
        image_array = image_data["image_array"]
        pred_df = image_data["predictions"]
        pred_img_obj = image_data["pred_img_obj"]
        boxes = image_data["boxes"]
        final_circles = image_data["final_circles"]

        # Layout: 3 columns
        col1, col2, col3 = st.columns([2, 2, 1])

        # Editable Canvas (Column 1)
        with col1:
            st.info(f"**Editable Canvas for Image: {file_name}**")
            detected_circles = st.session_state["processed_images"][file_name].get("final_circles", [])
            updated_circles = interactive_circle_editor(
                image_array, detected_circles, f"editable_canvas_{idx}"
            )
            if updated_circles != detected_circles:
                st.session_state["processed_images"][file_name]["final_circles"] = updated_circles
                st.session_state["processed_images"][file_name]["final_rendered_image"] = None  # Force re-rendering

        # Final Rendered Image with Updated Circles (Column 2)
        with col2:
            st.info(f"**Final Updated Image for {file_name}**")
            if (
                st.session_state["processed_images"][file_name]["final_rendered_image"] is None
                or updated_circles != final_circles
            ):
                # Re-render the image with final circles
                pred_df, final_rendered_img, boxes = get_image_prediction_circles(
                    image_array, yolo, updated_circles, file_name
                )
                st.session_state["processed_images"][file_name]["final_rendered_image"] = final_rendered_img
                st.session_state["processed_images"][file_name]["predictions"] = pred_df
                st.session_state["processed_images"][file_name]["boxes"] = boxes

            st.image(st.session_state["processed_images"][file_name]["final_rendered_image"])

        # Pixel-to-MM Ratio and Measurements (Column 3)
        with col3:
            st.info("**Bounding Box Results & Measurements (mm)**")
            final_circles = st.session_state["processed_images"][file_name].get("final_circles", [])
            if final_circles:
                pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                st.session_state["processed_images"][file_name]["pixel_to_mm_ratio"] = pixel_to_mm_ratio

                st.write(f"Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
                pred_df = st.session_state["processed_images"][file_name]["predictions"]
                measurements = bbox_results_measurements(
                    image_array, pixel_to_mm_ratio, pred_df
                )
                st.dataframe(measurements)
            else:
                st.write("No circles available for calculation. Please edit cooling holes.")

    # Optional: Summary Table
    st.markdown("## Summary Table")
    # Extract and display data as needed

if __name__ == "__main__":
    main()








def get_image_predictions(image_array, yolo, file_name, final_circles=None, draw_circles=False):
    """
    Retrieve image predictions and optionally draw circles. Leverages session state to reduce redundant processing.
    """
    # Initialize session state for this image if not already present
    if file_name not in st.session_state["processed_images"]:
        st.session_state["processed_images"][file_name] = {}

    # Check if predictions already exist in session state
    if "predictions" not in st.session_state["processed_images"][file_name]:
        # Run YOLO predictions
        category_list = ["2", "3", "4"]
        results = yolo.predictions(image_array)
        result = results[0]
        boxes = result.boxes

        # Prepare prediction details
        pred_df = {}
        pred_df["filename"] = file_name
        pred_df["pred_cls"] = [int(category_list[int(x)]) for x in boxes.cls.tolist()]
        pred_df["pred_conf"] = [round(x, 3) for x in boxes.conf.tolist()]
        pred_df["n_defects"] = len(pred_df["pred_cls"])
        pred_df["cls2_count"] = pred_df["pred_cls"].count(2)
        pred_df["cls3_count"] = pred_df["pred_cls"].count(3)
        pred_df["cls4_count"] = pred_df["pred_cls"].count(4)
        pred_df["pred_class"] = [category_list[int(x)] for x in boxes.cls.tolist()]
        pred_df["pred_conf"] = [round(x, 2) for x in boxes.conf.tolist()]

        # Save predictions to session state
        st.session_state["processed_images"][file_name]["predictions"] = {
            "pred_df": pred_df,
            "boxes": boxes,
        }

    else:
        # Retrieve from session state
        pred_df = st.session_state["processed_images"][file_name]["predictions"]["pred_df"]
        boxes = st.session_state["processed_images"][file_name]["predictions"]["boxes"]

    # Render image if requested
    pred_img_obj = None
    if draw_circles:
        result = yolo.predictions(image_array)[0]
        im_bgr = result.plot()

        # Draw final circles if provided
        if final_circles:
            for x, y, r in final_circles:
                cv2.circle(im_bgr, (int(x), int(y)), int(r), (0, 255, 0), 10)

        # Convert to PIL image for display
        pred_img_obj = Image.fromarray(im_bgr)
        st.session_state["processed_images"][file_name]["pred_img_obj"] = pred_img_obj

    # Return predictions and rendered image
    return pred_df, pred_img_obj, boxes

import streamlit as st
import numpy as np
from PIL import Image
from your_module import (
    get_image_predictions,              # Function to predict without circles
    get_image_prediction_circles,      # Function to predict with drawn circles
    interactive_circle_editor,          # Circle editing on canvas
    calculate_pixel_to_mm_ratio,        # Pixel-to-mm ratio calculation
    bbox_results_measurements,          # Bounding box measurements
)

# Ensure session state is initialized
if "processed_images" not in st.session_state:
    st.session_state["processed_images"] = {}

def main():
    # File uploader
    file_uploaded = st.file_uploader(
        "Upload Images", accept_multiple_files=True, type=["jpg", "png"]
    )

    if not file_uploaded:
        st.info("Please upload images to start.")
        return

    # Iterate through uploaded files
    for idx, file in enumerate(file_uploaded):
        file_name = file.name

        # Initialize session state for this image
        if file_name not in st.session_state["processed_images"]:
            image_array = np.array(Image.open(file))
            pred_df, pred_img_obj, boxes = get_image_predictions(image_array, yolo, file_name)
            st.session_state["processed_images"][file_name] = {
                "image_array": image_array,
                "predictions": pred_df,
                "pred_img_obj": pred_img_obj,
                "boxes": boxes,
                "final_circles": None,
                "pixel_to_mm_ratio": None,
                "final_rendered_image": None,
            }

        # Retrieve stored data
        image_data = st.session_state["processed_images"][file_name]
        image_array = image_data["image_array"]
        pred_df = image_data["predictions"]
        pred_img_obj = image_data["pred_img_obj"]
        boxes = image_data["boxes"]
        final_circles = image_data["final_circles"]

        # Layout: 3 columns
        col1, col2, col3 = st.columns([2, 2, 1])

        # Editable Canvas (Column 1)
        with col1:
            st.info(f"**Editable Canvas for Image: {file_name}**")
            detected_circles = st.session_state["processed_images"][file_name].get("final_circles", [])
            updated_circles = interactive_circle_editor(
                image_array, detected_circles, f"editable_canvas_{idx}"
            )
            if updated_circles != detected_circles:
                st.session_state["processed_images"][file_name]["final_circles"] = updated_circles
                st.session_state["processed_images"][file_name]["final_rendered_image"] = None  # Force re-rendering

        # Final Rendered Image with Updated Circles (Column 2)
        with col2:
            st.info(f"**Final Updated Image for {file_name}**")
            if (
                st.session_state["processed_images"][file_name]["final_rendered_image"] is None
                or updated_circles != final_circles
            ):
                # Re-render the image with final circles
                pred_df, final_rendered_img, boxes = get_image_prediction_circles(
                    image_array, yolo, updated_circles, file_name
                )
                st.session_state["processed_images"][file_name]["final_rendered_image"] = final_rendered_img
                st.session_state["processed_images"][file_name]["predictions"] = pred_df
                st.session_state["processed_images"][file_name]["boxes"] = boxes

            st.image(st.session_state["processed_images"][file_name]["final_rendered_image"])

        # Pixel-to-MM Ratio and Measurements (Column 3)
        with col3:
            st.info("**Bounding Box Results & Measurements (mm)**")
            final_circles = st.session_state["processed_images"][file_name].get("final_circles", [])
            if final_circles:
                pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                st.session_state["processed_images"][file_name]["pixel_to_mm_ratio"] = pixel_to_mm_ratio

                st.write(f"Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
                pred_df = st.session_state["processed_images"][file_name]["predictions"]
                measurements = bbox_results_measurements(
                    image_array, pixel_to_mm_ratio, pred_df
                )
                st.dataframe(measurements)
            else:
                st.write("No circles available for calculation. Please edit cooling holes.")

    # Optional: Summary Table
    st.markdown("## Summary Table")
    # Extract and display data as needed

if __name__ == "__main__":
    main()







with col2:
    st.info(f"**Final Updated Cooling Holes & Bboxes**")

    # Check if the image needs to be processed or if cached results can be used
    if (
        "final_rendered_image" not in processed_data
        or processed_data["final_circles"] != detected_circles
    ):
        # Re-run processing logic only if needed
        pred_df, prediction, final_rendered_image, pred_class, pred_conf, boxes = get_image_prediction_circles(
            image_array, yolo, processed_data["final_circles"], file
        )

        # Cache the results
        processed_data["final_rendered_image"] = final_rendered_image
        processed_data["pred_df"] = pred_df
        processed_data["pred_class"] = pred_class
        processed_data["pred_conf"] = pred_conf

        # Update session state
        st.session_state["processed_images"][file_name].update({
            "final_rendered_image": final_rendered_image,
            "pred_df": pred_df,
            "pred_class": pred_class,
            "pred_conf": pred_conf,
        })
    else:
        # Use cached results
        final_rendered_image = processed_data["final_rendered_image"]
        pred_df = processed_data["pred_df"]
        pred_class = processed_data["pred_class"]
        pred_conf = processed_data["pred_conf"]

    # Display the final rendered image
    st.image(final_rendered_image, caption="Final Rendered Image with Circles and Bboxes")




def main():
    # Step 1: File Upload
    if len(file_uploaded) > 1:
        for idx, file in enumerate(file_uploaded):
            file_name = file.name

            # Initialize or Retrieve Image-Specific State
            if file_name not in st.session_state["processed_images"]:
                # Process the image and store initial data in session state
                image_array = np.array(Image.open(file))
                pred_df, prediction, pred_img_obj, pred_class, pred_conf = get_image_prediction(
                    image_array, yolo, file
                )
                pixel_to_mm_ratio, processed_img_with_boxes, detected_circles = processed_image_circles(image_array)

                st.session_state["processed_images"][file_name] = {
                    "image_array": image_array,
                    "detected_circles": detected_circles,
                    "final_circles": None,
                    "pred_df": pred_df,
                    "prediction": prediction,
                    "pred_img_obj": pred_img_obj,
                    "pred_class": pred_class,
                    "pred_conf": pred_conf,
                    "pixel_to_mm_ratio": pixel_to_mm_ratio,
                    "final_rendered_image": None,
                }

            # Retrieve Data from Session State
            processed_data = st.session_state["processed_images"][file_name]
            image_array = processed_data["image_array"]
            detected_circles = processed_data["detected_circles"]
            final_circles = processed_data.get("final_circles", detected_circles)

            # Columns Layout
            col1, col2, col3 = st.columns([2, 2, 1])

            # Column 1: Editable Canvas for Circles
            with col1:
                st.info(f"**Editable Canvas for Image {file_name}:**")
                updated_circles = interactive_circle_editor(
                    image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
                )

                # If circles are updated, store in session state
                if updated_circles != detected_circles:
                    st.session_state["processed_images"][file_name]["final_circles"] = updated_circles
                    processed_data["final_circles"] = updated_circles

            # Column 2: Display Final Rendered Image with Bounding Boxes
            with col2:
                st.info(f"**Final Updated Cooling Holes & Bboxes**")

                # Check if final_rendered_image needs to be updated
                if (
                    processed_data["final_rendered_image"] is None
                    or processed_data["final_circles"] != detected_circles
                ):
                    pred_df, prediction, final_rendered_image, pred_class, pred_conf, boxes = get_image_prediction_circles(
                        processed_data["image_array"], yolo, processed_data["final_circles"], file
                    )
                    st.session_state["processed_images"][file_name]["final_rendered_image"] = final_rendered_image
                    st.session_state["processed_images"][file_name]["pred_df"] = pred_df
                    st.session_state["processed_images"][file_name]["prediction"] = prediction
                    st.session_state["processed_images"][file_name]["pred_class"] = pred_class
                    st.session_state["processed_images"][file_name]["pred_conf"] = pred_conf

                # Display the final rendered image
                st.image(processed_data["final_rendered_image"])

            # Column 3: Pixel-to-MM Ratio and Measurements
            with col3:
                st.info("**Bounding Box Results & Measurements (mm)**")

                if processed_data["final_circles"]:
                    pixel_to_mm_ratio = processed_data["pixel_to_mm_ratio"]
                    pred_df_f = bbox_results_measurements(
                        processed_data["image_array"], pixel_to_mm_ratio, processed_data["pred_df"]
                    )

                    # Store updated measurement data in session state
                    st.session_state["processed_images"][file_name]["pred_df"] = pred_df_f

                    # Display measurements
                    st.write(f"Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
                    for i, bbox_area in enumerate(pred_df_f["area in mm ^ 2"], start=1):
                        st.write(f"Bbox {i}: Area = {bbox_area:.2f} mm²")
                else:
                    st.write("No circles available for calculation.")

    # Optional Summary Table for Processed Images
    st.markdown("### Summary Table")
    selected_image_name = st.selectbox("Select an image to validate measurements:", list(st.session_state["processed_images"].keys()))
    if selected_image_name:
        selected_image_data = st.session_state["processed_images"][selected_image_name]
        measure_with_dynamic_canvas(selected_image_data["image_array"], selected_image_data["pixel_to_mm_ratio"])




def main():
    # Initialize session state for images if not already done
    if "processed_images" not in st.session_state:
        st.session_state["processed_images"] = {}

    # Process uploaded images
    list_images, num_img, pred_df_list = upload_zip_images(data_ch, yolo, file_uploaded)

    # Iterate through uploaded images
    for idx, file in enumerate(list_images):
        file_name = file.name
        st.header(f"Processing Image {idx + 1}: {file_name}")

        # Retrieve or initialize image-specific session state
        if file_name not in st.session_state["processed_images"]:
            image_array = np.array(Image.open(file))  # Load image into array
            st.session_state["processed_images"][file_name] = {
                "image_array": image_array,
                "detected_circles": None,
                "final_circles": None,
                "pred_df": None,
                "prediction": None,
                "pred_img_obj": None,
                "pixel_to_mm_ratio": None,
                "final_rendered_image": None,
            }

        # Get processed data from session state
        processed_data = st.session_state["processed_images"][file_name]
        image_array = processed_data["image_array"]

        with st.columns([2, 2, 1]) as (col1, col2, col3):

            # --- Column 1: Editable Canvas ---
            with col1:
                st.info(f"**Editable Canvas for Image {file_name}:**")
                detected_circles = processed_data.get("detected_circles", [])
                final_circles = interactive_circle_editor(
                    image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
                )
                # Update session state only if circles are modified
                if final_circles != detected_circles:
                    processed_data["final_circles"] = final_circles

            # --- Column 2: Final Rendered Image ---
            with col2:
                st.info(f"**Final Updated Cooling Holes & Bounding Boxes for {file_name}:**")
                # Check if "final_rendered_image" already exists
                if processed_data["final_rendered_image"] is None or final_circles != detected_circles:
                    (
                        pred_df,
                        prediction,
                        pred_img_obj,
                        pred_class,
                        pred_conf,
                        boxes,
                    ) = get_image_prediction(image_array, yolo, final_circles, file)

                    # Store results in session state
                    processed_data.update({
                        "pred_df": pred_df,
                        "prediction": prediction,
                        "pred_img_obj": pred_img_obj,
                        "pixel_to_mm_ratio": calculate_pixel_to_mm_ratio(final_circles),
                        "final_rendered_image": pred_img_obj,  # Use pred_img_obj as the rendered image
                    })

                # Display the final rendered image
                st.image(processed_data["final_rendered_image"])

            # --- Column 3: Measurements ---
            with col3:
                st.info(f"**Bounding Box Results & Measurements (mm):**")
                pixel_to_mm_ratio = processed_data.get("pixel_to_mm_ratio", None)
                if pixel_to_mm_ratio is not None:
                    pred_df = bbox_results_measurements(
                        image_array, pixel_to_mm_ratio, processed_data["pred_df"]
                    )
                    st.write(f"Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
                    processed_data["pred_df"] = pred_df
                else:
                    st.error("No circles available for calculation. Try editing cooling holes.")




def processed_image_with_final_circles(image_array, final_circles, yolo_model):
    """
    Process image with final circles and draw bounding boxes.
    Includes final circles post-editing.
    """
    # YOLO prediction to get bounding boxes
    results = yolo_model.predictions(image_array)
    pred_boxes = results[0].boxes if len(results) > 0 else []

    # Draw the final circles on the image
    for x, y, r in final_circles:
        cv2.circle(image_array, (int(x), int(y)), int(r), (0, 255, 0), 2)

    # Draw bounding boxes
    for box in pred_boxes:
        x1, y1, x2, y2 = map(int, box.xyxy)
        cv2.rectangle(image_array, (x1, y1), (x2, y2), (255, 0, 0), 2)

    # Calculate the pixel-to-mm ratio based on final circles
    pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)

    return image_array, pixel_to_mm_ratio, pred_boxes


def display_final_circles_canvas(image_array, final_circles, canvas_key):
    """
    Displays the final circles on a read-only canvas.

    Args:
        image_array (numpy.ndarray): The original image as a NumPy array.
        final_circles (list): Final list of circles (x, y, radius).
        canvas_key (str): Unique key for the display canvas.

    Returns:
        None
    """
    # Convert the image to PIL format
    background_image = Image.fromarray(image_array)

    # Draw the final circles on the image
    draw = ImageDraw.Draw(background_image)
    for x, y, r in final_circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline="green", width=3)

    # Display a read-only canvas with the final circles
    st_canvas(
        fill_color=None,  # No fill color for read-only
        stroke_width=0,   # No drawing allowed
        stroke_color=None,
        background_image=background_image,
        update_streamlit=False,  # Static display
        height=background_image.size[1],
        width=background_image.size[0],
        drawing_mode=None,  # Disable drawing
        key=canvas_key,
    )



def dynamic_circle_editor_with_updates(image_array, final_circles, canvas_key):
    """
    Unified canvas that dynamically updates with the final circles after modifications.

    Args:
        image_array (numpy.ndarray): Original image as a NumPy array.
        final_circles (list): Final circles to render (x, y, radius).
        canvas_key (str): Unique key for the canvas.

    Returns:
        list: Updated list of final circles after user actions.
    """
    # Convert image to PIL format for background rendering
    background_image = Image.fromarray(image_array)

    # Draw only the final circles dynamically
    draw = ImageDraw.Draw(background_image)
    for x, y, r in final_circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline="green", width=3)

    # Display the canvas
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",  # Transparent fill for new circles
        stroke_width=2,
        stroke_color="blue",
        background_image=background_image,
        update_streamlit=True,
        height=background_image.size[1],
        width=background_image.size[0],
        drawing_mode="circle",
        key=canvas_key,
    )

    # Process new circles added via canvas
    new_circles = []
    if canvas_result and canvas_result.json_data:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                x_center = obj["left"] + obj["width"] / 2
                y_center = obj["top"] + obj["height"] / 2
                radius = obj["width"] / 2
                new_circles.append((x_center, y_center, radius))

    # Allow user to remove specific circles dynamically
    selected_to_remove = st.multiselect(
        f"Select circles to remove (index-based):",
        options=list(range(len(final_circles))),
        format_func=lambda i: f"Circle {i + 1}: {final_circles[i]}",
        key=f"remove_multiselect_{canvas_key}",
    )

    # Filter out the removed circles
    updated_final_circles = [
        circle for i, circle in enumerate(final_circles) if i not in selected_to_remove
    ]

    # Add the new circles drawn on the canvas
    updated_final_circles.extend(new_circles)

    return updated_final_circles





def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated circles.
    Ensures only valid and unique circles are retained.

    Args:
        updated_circles (list): Circles added or modified via the canvas.
        original_circles (list): Original detected circles.
        image_key (str): Unique key for identifying image-specific actions in Streamlit.

    Returns:
        list: Final combined list of circles (filtered and updated).
    """
    # Step 1: Display original circles
    st.write(f"Original Circles for {image_key}: {original_circles}")

    # Step 2: Option to remove specific circles
    selected_to_remove = []
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i + 1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}",
        )
    filtered_original_circles = [
        circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
    ]

    # Debug: Display filtered circles
    st.write(f"Filtered Original Circles for {image_key}: {filtered_original_circles}")

    # Step 3: Combine filtered original circles with updated circles (if any)
    final_circles = filtered_original_circles + updated_circles
    final_circles = list({tuple(circle) for circle in final_circles})  # Ensure unique circles
    final_circles = sorted(final_circles, key=lambda x: (x[0], x[1]))  # Sort by X and Y

    # Debug: Display final circles
    st.write(f"Final Circles for {image_key}: {final_circles}")

    return final_circles


def draw_final_circles_on_canvas(final_circles, canvas_key, image_array):
    """
    Render the final circles dynamically on the canvas and allow further modifications.

    Args:
        final_circles (list): Final combined list of circles to display.
        canvas_key (str): Unique key for the canvas to avoid conflicts.
        image_array (numpy.ndarray): Original image as a NumPy array.

    Returns:
        list: Updated list of circles after interactions.
    """
    # Prepare the background image
    background_image = Image.fromarray(image_array)

    # Draw existing final circles on the image
    for circle in final_circles:
        x, y, r = circle
        draw = ImageDraw.Draw(background_image)
        draw.ellipse(
            (x - r, y - r, x + r, y + r), outline="red", width=3
        )

    # Render the canvas
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="blue",
        background_image=background_image,
        update_streamlit=True,
        height=background_image.size[1],
        width=background_image.size[0],
        drawing_mode="circle",
        key=canvas_key,
    )

    # Process new additions or modifications from the canvas
    updated_circles = []
    if canvas_result and canvas_result.json_data:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                x_center = obj["left"] + obj["width"] / 2
                y_center = obj["top"] + obj["height"] / 2
                radius = obj["width"] / 2
                updated_circles.append((x_center, y_center, radius))

    # Combine existing and updated circles
    final_circles = list({tuple(circle) for circle in (final_circles + updated_circles)})

    return final_circles

with col2:
    # Interactive Canvas for Circle Editing
    st.info(f"Editable Canvas for Image {file.name}:")
    updated_circles = interactive_circle_editor(
        image_array=image_array,
        detected_circles=detected_circles,
        image_key=f"editable_canvas_{idx}"
    )

    # Filter and Combine Circles
    st.write(f"Filter and Combine Circles for Image {file.name}:")
    final_circles = filter_and_combine_circles(
        updated_circles=updated_circles,
        original_circles=detected_circles,
        image_key=f"image_{idx}"
    )

    # Dynamically Render Final Circles on Canvas
    final_circles = draw_final_circles_on_canvas(
        final_circles=final_circles,
        canvas_key=f"final_canvas_{idx}",
        image_array=image_array
    )

    # Display Final Circles in Table Format
    st.write(f"Circle Data in Table Format for Image {idx + 1}:")
    detected_df = circles_to_dataframe(
        detected_circles,
        label=f"Detected Circle (Image {idx + 1})"
    )
    st.write("Detected Circles:")
    st.dataframe(detected_df)

    if final_circles:
        final_df = circles_to_dataframe(
            final_circles,
            label=f"Final Circle (Image {idx + 1})"
        )
        st.write("Final Circles:")
        st.dataframe(final_df)

with col3:
    # Display Bounding Box Results and Measurements
    st.info("**Bounding Box Results & Measurements (mm)**")
    st.write("Defect class:", pred_class)
    st.write("Defect class confidence:", pred_conf)

    # Calculate and Display Pixel-to-MM Ratio
    if final_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
    else:
        st.write("No circles available for calculation.")




def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated circles.
    Ensures only valid and unique circles are retained.

    Args:
        updated_circles (list): Circles added or modified via the canvas.
        original_circles (list): Original detected circles.
        image_key (str): Unique key for identifying image-specific actions in Streamlit.

    Returns:
        list: Final combined list of circles (filtered and updated).
    """
    # Debug: Display original and updated circles
    st.write(f"Original Circles for {image_key}: {original_circles}")
    st.write(f"Updated Circles from Canvas for {image_key}: {updated_circles}")

    # Initialize filtered circles
    filtered_original_circles = original_circles[:]

    # Option to remove specific circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i + 1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )

        # Filter out the selected circles
        filtered_original_circles = [
            circle for i, circle in enumerate(original_circles) 
            if i not in selected_to_remove
        ]
        # Debug: Check filtered circles
        st.write(f"Filtered Original Circles (after removal): {filtered_original_circles}")
    else:
        st.write("No circles removed; using all detected circles.")

    # Combine filtered original circles with updated circles
    if updated_circles:  # Only combine if updated circles exist
        combined_circles = filtered_original_circles + updated_circles
    else:
        combined_circles = filtered_original_circles

    # Ensure unique circles (avoid duplicates)
    final_circles = list({tuple(circle) for circle in combined_circles})

    # Sort final circles (optional, based on x and y coordinates)
    final_circles = sorted(final_circles, key=lambda x: (x[0], x[1]))

    # Debug: Display final circles
    st.write(f"Final Circles for {image_key}: {final_circles}")

    return final_circles




def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated circles.
    Returns the final list of circles after filtering and combining.

    Args:
        updated_circles (list): Circles added or modified via the canvas.
        original_circles (list): Original detected circles.
        image_key (str): Unique key for identifying image-specific actions in Streamlit.

    Returns:
        list: Final combined list of circles (filtered and updated).
    """
    # Display the original and updated circles
    st.write(f"Original Circles for {image_key}: {original_circles}")
    st.write(f"Updated Circles from Canvas for {image_key}: {updated_circles}")

    # Option to remove specific circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i + 1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )

        # Filter out the selected circles
        filtered_original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
    else:
        # No removal; keep all original circles
        filtered_original_circles = original_circles

    # Combine the filtered original circles with updated circles
    combined_circles = filtered_original_circles + updated_circles

    # Ensure unique circles (no duplicates) using a set
    final_circles = list({tuple(circle) for circle in combined_circles})

    # Sort final circles for consistent order (optional, based on x-coordinate)
    final_circles = sorted(final_circles, key=lambda x: (x[0], x[1]))

    # Display the final combined circles for debugging
    st.write(f"Final Circles for {image_key}: {final_circles}")

    return final_circles




import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw circles on the image
def draw_circles(image_array, circles, color="blue"):
    """
    Draw circles (original, updated, or final) on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Interactive canvas for updating circles
def interactive_circle_editor(image_array, current_circles, image_key, max_width=400):
    """
    Canvas for displaying and editing circles interactively.
    """
    # Draw circles on the image
    image = draw_circles(image_array, current_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else current_circles

# Convert circles to DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Main application
with st.container():
    # File uploader stays at the top
    st.header("Upload data here:")
    file_uploaded = st.file_uploader(
        "Upload Images (PNG, JPG, JPEG)", 
        type=["png", "jpg", "jpeg"], 
        accept_multiple_files=True
    )

# Results container to display processed data
if file_uploaded:
    with st.container():
        # Dynamically adjust layout based on the number of uploaded images
        if len(file_uploaded) > 10:
            # Use a dropdown selector for more than 10 images
            image_selector = st.selectbox(
                "Select an Image to Process:",
                options=[(idx, file.name) for idx, file in enumerate(file_uploaded)],
                format_func=lambda x: f"Image {x[0] + 1}: {x[1]}",
            )
            selected_idx, selected_file = image_selector
            file_uploaded = [file_uploaded[selected_idx]]  # Only process the selected file

        # Process each image
        for idx, file in enumerate(file_uploaded):
            image_array = np.array(Image.open(file))
            detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

            # Display results
            st.title(f"Image {idx + 1}: {file.name}")

            # Three-column layout
            col1, col2, col3 = st.columns([2, 2, 1])

            # Original image with detected circles
            with col1:
                st.write(f"Original Image {idx + 1} with Detected Circles:")
                detected_image = draw_circles(image_array, detected_circles, color="red")
                st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

            # Editable canvas with updated circles
            with col2:
                st.write(f"Editable Canvas for Image {idx + 1}:")
                updated_circles = interactive_circle_editor(
                    image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
                )

                # Filter and combine circles
                st.write(f"Filter and Combine Circles for Image {idx + 1}:")
                final_circles = list(set(detected_circles + updated_circles))  # Avoid duplication

            # Results and DataFrames
            with col3:
                st.write(f"Circle Data in Table Format for Image {idx + 1}:")

                # Detected Circles Table
                detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
                st.write("Detected Circles:")
                st.dataframe(detected_df)

                # Updated Circles Table
                updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
                st.write("Updated Circles:")
                st.dataframe(updated_df)

                # Final Circles Table
                final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
                st.write("Final Circles:")
                st.dataframe(final_df)

                # Pixel-to-mm Ratio
                if final_circles:
                    pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                    st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
                else:
                    st.write("No circles available for calculation.")




import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw circles on the image
def draw_circles(image_array, circles, color="blue"):
    """
    Draw circles (original, updated, or final) on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Interactive canvas for updating circles
def interactive_circle_editor(image_array, current_circles, image_key, max_width=400):
    """
    Canvas for displaying and editing circles interactively.
    """
    # Draw circles on the image
    image = draw_circles(image_array, current_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else current_circles

# Function to filter and combine circles
def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them.
    """
    st.write(f"Original Circles for {image_key}:", original_circles)
    st.write(f"Updated Circles from Canvas for {image_key}:", updated_circles)

    # Option to remove specific circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write(f"Filtered Circles for {image_key}:", original_circles)

    # Combine filtered and updated circles
    return list(set(original_circles + updated_circles))

# Convert circles to DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Calculate pixel-to-mm ratio
def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
    """
    Calculate pixel-to-mm ratio based on circles.
    """
    if not circles:
        return None
    avg_diameter_px = np.mean([2 * r for _, _, r in circles])
    return known_diameter_mm / avg_diameter_px

# File uploader for multiple images
file_uploaded = st.file_uploader("Upload Images", type=["png", "jpg", "jpeg"], accept_multiple_files=True)

if file_uploaded:
    # Add tabs for each image
    tabs = st.tabs([f"Image {idx + 1}" for idx in range(len(file_uploaded))])

    for idx, (file, tab) in enumerate(zip(file_uploaded, tabs)):
        with tab:
            # Load the image
            image_array = np.array(Image.open(file))
            detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

            st.title(f"Image {idx + 1}")

            # Column layout
            col1, col2, col3 = st.columns([2, 2, 1])

            # Original image with detected circles
            with col1:
                st.write(f"Original Image {idx + 1} with Detected Circles:")
                detected_image = draw_circles(image_array, detected_circles, color="red")
                st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

            # Editable canvas with updated circles
            with col2:
                st.write(f"Editable Canvas for Image {idx + 1}:")
                updated_circles = interactive_circle_editor(
                    image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
                )

                # Filter and combine circles
                st.write(f"Filter and Combine Circles for Image {idx + 1}:")
                final_circles = filter_and_combine_circles(updated_circles, detected_circles, f"image_{idx}")

            # Results and DataFrames
            with col3:
                st.write(f"Circle Data in Table Format for Image {idx + 1}:")

                # Detected Circles Table
                detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
                st.write("Detected Circles:")
                st.dataframe(detected_df)

                # Updated Circles Table
                updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
                st.write("Updated Circles:")
                st.dataframe(updated_df)

                # Final Circles Table
                final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
                st.write("Final Circles:")
                st.dataframe(final_df)

                # Pixel-to-mm Ratio
                if final_circles:
                    pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                    st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
                else:
                    st.write("No circles available for calculation.")



import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw detected circles on the image
def draw_detected_circles(image_array, circles, color="red"):
    """
    Draw detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to draw final updated circles on the image
def draw_final_circles(image_array, circles, color="green"):
    """
    Draw updated or final circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to handle interactive circle updates
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Editable canvas that dynamically updates circles.
    """
    # Draw the detected circles on the image
    image = draw_detected_circles(image_array, detected_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else detected_circles

# Function to convert circles to a pandas DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Function to filter and combine circles
def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated ones.
    """
    st.write(f"Original Circles for {image_key}:", original_circles)
    st.write(f"Updated Circles from Canvas for {image_key}:", updated_circles)

    # Option to remove specific detected circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write(f"Filtered Circles for {image_key}:", original_circles)

    # Combine filtered original circles and updated circles
    final_circles = original_circles + updated_circles
    return final_circles

# Placeholder function to calculate pixel-to-mm ratio
def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
    """
    Calculate pixel-to-mm ratio based on detected or updated circles.
    """
    if not circles:
        return None
    avg_diameter_px = np.mean([2 * r for _, _, r in circles])
    return known_diameter_mm / avg_diameter_px

# File uploader for multiple images
file_uploaded = st.file_uploader("Upload Images", type=["png", "jpg", "jpeg"], accept_multiple_files=True)

if file_uploaded:
    for idx, file in enumerate(file_uploaded):
        # Load the image (convert to NumPy array for example purposes)
        image_array = np.array(Image.open(file))
        detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

        st.title(f"Image {idx + 1}")

        # Three-column layout
        col1, col2, col3 = st.columns([2, 2, 1])

        # Original image with detected circles
        with col1:
            st.write(f"Original Image {idx + 1} with Detected Circles:")
            detected_image = draw_detected_circles(image_array, detected_circles, color="red")
            st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

        # Editable canvas with updated circles
        with col2:
            st.write(f"Editable Canvas for Image {idx + 1}:")
            updated_circles = interactive_circle_editor(
                image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
            )

            # Filter and combine circles
            st.write(f"Filter and Combine Circles for Image {idx + 1}:")
            final_circles = filter_and_combine_circles(updated_circles, detected_circles, f"image_{idx}")

        # Results and DataFrames
        with col3:
            st.write(f"Circle Data in Table Format for Image {idx + 1}:")

            # Detected Circles Table
            detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
            st.write("Detected Circles:")
            st.dataframe(detected_df)

            # Updated Circles Table
            updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
            st.write("Updated Circles:")
            st.dataframe(updated_df)

            # Final Circles Table
            final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
            st.write("Final Circles:")
            st.dataframe(final_df)

            # Pixel-to-mm Ratio
            if final_circles:
                pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
            else:
                st.write("No circles available for calculation.")





if len(file_uploaded) > 1:
    for idx, file in enumerate(file_uploaded):
        # Load the image and process it (replace with your actual image handling logic)
        image_array = ...  # Load your image here as a NumPy array
        detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

        st.title(f"Image {idx + 1}")

        # Three-column layout
        col1, col2, col3 = st.columns([2, 2, 1])

        # Original image with detected circles
        with col1:
            st.write(f"Original Image {idx + 1} with Detected Circles:")
            detected_image = draw_detected_circles(image_array, detected_circles, color="red")
            st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

        # Editable canvas with updated circles
        with col2:
            st.write(f"Editable Canvas for Image {idx + 1}:")
            updated_circles = interactive_circle_editor(
                image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
            )

            # Filter and combine circles
            st.write(f"Filter and Combine Circles for Image {idx + 1}:")
            final_circles = filter_and_combine_circles(updated_circles, detected_circles, f"image_{idx}")

        # Results and DataFrames
        with col3:
            st.write(f"Circle Data in Table Format for Image {idx + 1}:")

            # Detected Circles Table
            detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
            st.write("Detected Circles:")
            st.dataframe(detected_df)

            # Updated Circles Table
            updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
            st.write("Updated Circles:")
            st.dataframe(updated_df)

            # Final Circles Table
            final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
            st.write("Final Circles:")
            st.dataframe(final_df)

            # Pixel-to-mm Ratio
            if final_circles:
                pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
            else:
                st.write("No circles available for calculation.")




import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw detected circles on the image
def draw_detected_circles(image_array, circles, color="red"):
    """
    Draw detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to draw final updated circles on the image
def draw_final_circles(image_array, circles, color="green"):
    """
    Draw updated or final circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to handle interactive circle updates
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Editable canvas that dynamically updates circles.
    """
    # Draw the detected circles on the image
    image = draw_detected_circles(image_array, detected_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else detected_circles

# Function to convert circles to a pandas DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Placeholder function to calculate pixel-to-mm ratio
def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
    """
    Calculate pixel-to-mm ratio based on detected or updated circles.
    """
    if not circles:
        return None
    avg_diameter_px = np.mean([2 * r for _, _, r in circles])
    return known_diameter_mm / avg_diameter_px

# Placeholder image and circle data
image_array = np.ones((500, 500, 3), dtype=np.uint8) * 255  # Example white image
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

# Streamlit layout
st.title("Interactive Circle Editor and Results")

# Three-column layout
col1, col2, col3 = st.columns([2, 2, 1])

# Original image with detected circles
with col1:
    st.write("Original Image with Detected Circles:")
    detected_image = draw_detected_circles(image_array, detected_circles, color="red")
    st.image(detected_image, caption="Detected Circles", use_column_width=True)

# Editable canvas with updated circles
with col2:
    st.write("Editable Canvas with Updated Circles:")
    updated_circles = interactive_circle_editor(
        image_array, detected_circles, "editable_canvas", max_width=400
    )

    # Optional: Show updated circles as a static image
    st.write("Updated Circles (Image):")
    updated_image = draw_final_circles(image_array, updated_circles, color="green")
    st.image(updated_image, caption="Updated Circles", use_column_width=True)

# Results and DataFrames
with col3:
    st.write("Circle Data in Table Format:")

    # Detected Circles Table
    detected_df = circles_to_dataframe(detected_circles, label="Detected Circle")
    st.write("Detected Circles:")
    st.dataframe(detected_df)

    # Updated Circles Table
    updated_df = circles_to_dataframe(updated_circles, label="Updated Circle")
    st.write("Updated Circles:")
    st.dataframe(updated_df)

    # Pixel-to-mm Ratio
    if updated_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(updated_circles)
        st.write(f"Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
    else:
        st.write("No circles available for calculation.")




from PIL import Image, ImageDraw
import numpy as np
import streamlit as st
from streamlit_drawable_canvas import st_canvas

# Function to draw the detected circles on the image
def draw_detected_circles(image_array, circles):
    """
    Draw the detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline="red", width=2)
    return image

# Interactive circle editor
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Display the image with detected circles and allow interactive editing.
    """
    # Convert the image to a PIL Image
    image = draw_detected_circles(image_array, detected_circles)
    original_width, original_height = image.size

    # Calculate new display dimensions while preserving aspect ratio
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0  # No scaling needed

    # Scaling factors for converting between display and original dimensions
    scale_x = original_width / display_width
    scale_y = original_height / display_height

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",  # Fill for new circles
        stroke_width=2,
        stroke_color="blue",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )
    
    # Extract updated circles from canvas data
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] * scale_x
                top = obj["top"] * scale_y
                width = obj["width"] * scale_x
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles, scale

# Function to combine and filter circles
def filter_and_combine_circles(updated_circles, original_circles):
    """
    Allow users to remove unwanted original circles and combine them with updated ones.
    """
    st.write("Original Detected Circles:", original_circles)
    st.write("Updated Circles from Canvas:", updated_circles)

    # Option to remove specific detected circles
    if st.checkbox("Remove detected circles?"):
        selected_to_remove = st.multiselect(
            "Select detected circles to remove (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write("Filtered Original Circles:", original_circles)
    
    # Combine filtered original circles and updated circles
    final_circles = original_circles + updated_circles
    return final_circles

# Example integration in Streamlit
st.title("Interactive Circle Editor with Dynamic Pixel-to-MM Updates")

# Example image and circle data
image_array = ...  # Replace with your image as a NumPy array
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example original circles

# Layout with three columns
col1, col2, col3 = st.columns([2, 1, 1])  # Adjust width ratios as needed

with col1:
    st.write("Canvas with Detected Circles:")
    updated_circles, scale = interactive_circle_editor(image_array, detected_circles, "example_image", max_width=400)

with col2:
    st.write("Combine and Filter Circles:")
    final_circles = filter_and_combine_circles(updated_circles, detected_circles)

with col3:
    st.write("Pixel-to-MM Ratio and Results:")
    if final_circles:
        # Example function for pixel-to-mm ratio
        def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
            avg_diameter_px = np.mean([2 * r for _, _, r in circles])
            return known_diameter_mm / avg_diameter_px

        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Updated Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
        st.write("Final Circles Used for Calculation:")
        st.json(final_circles)
    else:
        st.write("No circles available for calculation.")








def interactive_circle_editor(image_array, detected_circles, image_key, max_width=300):
    """
    Display the image in a canvas within a column without distortion and allow circle editing.
    """
    from PIL import Image, ImageDraw

    # Convert the image to a PIL Image
    image = Image.fromarray(image_array)
    original_width, original_height = image.size
    
    # Calculate new display dimensions while preserving aspect ratio
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0  # No scaling needed

    # Scaling factors for converting between display and original dimensions
    scale_x = original_width / display_width
    scale_y = original_height / display_height

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",  # Fill for new circles
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )
    
    # Extract updated circles from canvas data
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] * scale_x
                top = obj["top"] * scale_y
                width = obj["width"] * scale_x
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles, scale

def filter_circles(updated_circles, original_circles):
    """
    Allow users to deselect or remove unwanted original circles.
    """
    st.write("Original Circles:", original_circles)
    st.write("Updated Circles:", updated_circles)

    # Example: Remove a specific circle
    if st.checkbox("Remove unwanted circles?"):
        selected_to_remove = st.multiselect(
            "Select circles to remove (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write("Filtered Circles:", original_circles)
    
    # Combine updated and remaining original circles
    final_circles = original_circles + updated_circles
    return final_circles

# Example integration in a three-column layout
st.title("Interactive Circle Editor with Three Columns")

# Example image and circle data
image_array = ...  # Replace with your image as a NumPy array
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example original circles

# Three-column layout
col1, col2, col3 = st.columns([2, 1, 1])  # Adjust width ratios as needed

with col1:
    st.write("Canvas for Editing Circles:")
    updated_circles, scale = interactive_circle_editor(image_array, detected_circles, "example_image", max_width=300)

with col2:
    st.write("Circle Data:")
    final_circles = filter_circles(updated_circles, detected_circles)

with col3:
    st.write("Pixel-to-MM Ratio and Results:")
    if final_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Updated Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
        st.write("Final Circles Used:")
        st.json(final_circles)
    else:
        st.write("No circles to calculate.")