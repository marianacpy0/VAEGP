import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw detected circles on the image
def draw_detected_circles(image_array, circles, color="red"):
    """
    Draw detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to draw final updated circles on the image
def draw_final_circles(image_array, circles, color="green"):
    """
    Draw updated or final circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to handle interactive circle updates
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Editable canvas that dynamically updates circles.
    """
    # Draw the detected circles on the image
    image = draw_detected_circles(image_array, detected_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else detected_circles

# Function to convert circles to a pandas DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Placeholder function to calculate pixel-to-mm ratio
def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
    """
    Calculate pixel-to-mm ratio based on detected or updated circles.
    """
    if not circles:
        return None
    avg_diameter_px = np.mean([2 * r for _, _, r in circles])
    return known_diameter_mm / avg_diameter_px

# Placeholder image and circle data
image_array = np.ones((500, 500, 3), dtype=np.uint8) * 255  # Example white image
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

# Streamlit layout
st.title("Interactive Circle Editor and Results")

# Three-column layout
col1, col2, col3 = st.columns([2, 2, 1])

# Original image with detected circles
with col1:
    st.write("Original Image with Detected Circles:")
    detected_image = draw_detected_circles(image_array, detected_circles, color="red")
    st.image(detected_image, caption="Detected Circles", use_column_width=True)

# Editable canvas with updated circles
with col2:
    st.write("Editable Canvas with Updated Circles:")
    updated_circles = interactive_circle_editor(
        image_array, detected_circles, "editable_canvas", max_width=400
    )

    # Optional: Show updated circles as a static image
    st.write("Updated Circles (Image):")
    updated_image = draw_final_circles(image_array, updated_circles, color="green")
    st.image(updated_image, caption="Updated Circles", use_column_width=True)

# Results and DataFrames
with col3:
    st.write("Circle Data in Table Format:")

    # Detected Circles Table
    detected_df = circles_to_dataframe(detected_circles, label="Detected Circle")
    st.write("Detected Circles:")
    st.dataframe(detected_df)

    # Updated Circles Table
    updated_df = circles_to_dataframe(updated_circles, label="Updated Circle")
    st.write("Updated Circles:")
    st.dataframe(updated_df)

    # Pixel-to-mm Ratio
    if updated_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(updated_circles)
        st.write(f"Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
    else:
        st.write("No circles available for calculation.")




from PIL import Image, ImageDraw
import numpy as np
import streamlit as st
from streamlit_drawable_canvas import st_canvas

# Function to draw the detected circles on the image
def draw_detected_circles(image_array, circles):
    """
    Draw the detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline="red", width=2)
    return image

# Interactive circle editor
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Display the image with detected circles and allow interactive editing.
    """
    # Convert the image to a PIL Image
    image = draw_detected_circles(image_array, detected_circles)
    original_width, original_height = image.size

    # Calculate new display dimensions while preserving aspect ratio
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0  # No scaling needed

    # Scaling factors for converting between display and original dimensions
    scale_x = original_width / display_width
    scale_y = original_height / display_height

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",  # Fill for new circles
        stroke_width=2,
        stroke_color="blue",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )
    
    # Extract updated circles from canvas data
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] * scale_x
                top = obj["top"] * scale_y
                width = obj["width"] * scale_x
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles, scale

# Function to combine and filter circles
def filter_and_combine_circles(updated_circles, original_circles):
    """
    Allow users to remove unwanted original circles and combine them with updated ones.
    """
    st.write("Original Detected Circles:", original_circles)
    st.write("Updated Circles from Canvas:", updated_circles)

    # Option to remove specific detected circles
    if st.checkbox("Remove detected circles?"):
        selected_to_remove = st.multiselect(
            "Select detected circles to remove (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write("Filtered Original Circles:", original_circles)
    
    # Combine filtered original circles and updated circles
    final_circles = original_circles + updated_circles
    return final_circles

# Example integration in Streamlit
st.title("Interactive Circle Editor with Dynamic Pixel-to-MM Updates")

# Example image and circle data
image_array = ...  # Replace with your image as a NumPy array
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example original circles

# Layout with three columns
col1, col2, col3 = st.columns([2, 1, 1])  # Adjust width ratios as needed

with col1:
    st.write("Canvas with Detected Circles:")
    updated_circles, scale = interactive_circle_editor(image_array, detected_circles, "example_image", max_width=400)

with col2:
    st.write("Combine and Filter Circles:")
    final_circles = filter_and_combine_circles(updated_circles, detected_circles)

with col3:
    st.write("Pixel-to-MM Ratio and Results:")
    if final_circles:
        # Example function for pixel-to-mm ratio
        def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
            avg_diameter_px = np.mean([2 * r for _, _, r in circles])
            return known_diameter_mm / avg_diameter_px

        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Updated Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
        st.write("Final Circles Used for Calculation:")
        st.json(final_circles)
    else:
        st.write("No circles available for calculation.")








def interactive_circle_editor(image_array, detected_circles, image_key, max_width=300):
    """
    Display the image in a canvas within a column without distortion and allow circle editing.
    """
    from PIL import Image, ImageDraw

    # Convert the image to a PIL Image
    image = Image.fromarray(image_array)
    original_width, original_height = image.size
    
    # Calculate new display dimensions while preserving aspect ratio
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0  # No scaling needed

    # Scaling factors for converting between display and original dimensions
    scale_x = original_width / display_width
    scale_y = original_height / display_height

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",  # Fill for new circles
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )
    
    # Extract updated circles from canvas data
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] * scale_x
                top = obj["top"] * scale_y
                width = obj["width"] * scale_x
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles, scale

def filter_circles(updated_circles, original_circles):
    """
    Allow users to deselect or remove unwanted original circles.
    """
    st.write("Original Circles:", original_circles)
    st.write("Updated Circles:", updated_circles)

    # Example: Remove a specific circle
    if st.checkbox("Remove unwanted circles?"):
        selected_to_remove = st.multiselect(
            "Select circles to remove (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write("Filtered Circles:", original_circles)
    
    # Combine updated and remaining original circles
    final_circles = original_circles + updated_circles
    return final_circles

# Example integration in a three-column layout
st.title("Interactive Circle Editor with Three Columns")

# Example image and circle data
image_array = ...  # Replace with your image as a NumPy array
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example original circles

# Three-column layout
col1, col2, col3 = st.columns([2, 1, 1])  # Adjust width ratios as needed

with col1:
    st.write("Canvas for Editing Circles:")
    updated_circles, scale = interactive_circle_editor(image_array, detected_circles, "example_image", max_width=300)

with col2:
    st.write("Circle Data:")
    final_circles = filter_circles(updated_circles, detected_circles)

with col3:
    st.write("Pixel-to-MM Ratio and Results:")
    if final_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Updated Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
        st.write("Final Circles Used:")
        st.json(final_circles)
    else:
        st.write("No circles to calculate.")