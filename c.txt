def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated circles.
    Ensures only valid and unique circles are retained.

    Args:
        updated_circles (list): Circles added or modified via the canvas.
        original_circles (list): Original detected circles.
        image_key (str): Unique key for identifying image-specific actions in Streamlit.

    Returns:
        list: Final combined list of circles (filtered and updated).
    """
    # Step 1: Display original circles
    st.write(f"Original Circles for {image_key}: {original_circles}")

    # Step 2: Option to remove specific circles
    selected_to_remove = []
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i + 1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}",
        )
    filtered_original_circles = [
        circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
    ]

    # Debug: Display filtered circles
    st.write(f"Filtered Original Circles for {image_key}: {filtered_original_circles}")

    # Step 3: Combine filtered original circles with updated circles (if any)
    final_circles = filtered_original_circles + updated_circles
    final_circles = list({tuple(circle) for circle in final_circles})  # Ensure unique circles
    final_circles = sorted(final_circles, key=lambda x: (x[0], x[1]))  # Sort by X and Y

    # Debug: Display final circles
    st.write(f"Final Circles for {image_key}: {final_circles}")

    return final_circles


def draw_final_circles_on_canvas(final_circles, canvas_key, image_array):
    """
    Render the final circles dynamically on the canvas and allow further modifications.

    Args:
        final_circles (list): Final combined list of circles to display.
        canvas_key (str): Unique key for the canvas to avoid conflicts.
        image_array (numpy.ndarray): Original image as a NumPy array.

    Returns:
        list: Updated list of circles after interactions.
    """
    # Prepare the background image
    background_image = Image.fromarray(image_array)

    # Draw existing final circles on the image
    for circle in final_circles:
        x, y, r = circle
        draw = ImageDraw.Draw(background_image)
        draw.ellipse(
            (x - r, y - r, x + r, y + r), outline="red", width=3
        )

    # Render the canvas
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="blue",
        background_image=background_image,
        update_streamlit=True,
        height=background_image.size[1],
        width=background_image.size[0],
        drawing_mode="circle",
        key=canvas_key,
    )

    # Process new additions or modifications from the canvas
    updated_circles = []
    if canvas_result and canvas_result.json_data:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                x_center = obj["left"] + obj["width"] / 2
                y_center = obj["top"] + obj["height"] / 2
                radius = obj["width"] / 2
                updated_circles.append((x_center, y_center, radius))

    # Combine existing and updated circles
    final_circles = list({tuple(circle) for circle in (final_circles + updated_circles)})

    return final_circles

with col2:
    # Interactive Canvas for Circle Editing
    st.info(f"Editable Canvas for Image {file.name}:")
    updated_circles = interactive_circle_editor(
        image_array=image_array,
        detected_circles=detected_circles,
        image_key=f"editable_canvas_{idx}"
    )

    # Filter and Combine Circles
    st.write(f"Filter and Combine Circles for Image {file.name}:")
    final_circles = filter_and_combine_circles(
        updated_circles=updated_circles,
        original_circles=detected_circles,
        image_key=f"image_{idx}"
    )

    # Dynamically Render Final Circles on Canvas
    final_circles = draw_final_circles_on_canvas(
        final_circles=final_circles,
        canvas_key=f"final_canvas_{idx}",
        image_array=image_array
    )

    # Display Final Circles in Table Format
    st.write(f"Circle Data in Table Format for Image {idx + 1}:")
    detected_df = circles_to_dataframe(
        detected_circles,
        label=f"Detected Circle (Image {idx + 1})"
    )
    st.write("Detected Circles:")
    st.dataframe(detected_df)

    if final_circles:
        final_df = circles_to_dataframe(
            final_circles,
            label=f"Final Circle (Image {idx + 1})"
        )
        st.write("Final Circles:")
        st.dataframe(final_df)

with col3:
    # Display Bounding Box Results and Measurements
    st.info("**Bounding Box Results & Measurements (mm)**")
    st.write("Defect class:", pred_class)
    st.write("Defect class confidence:", pred_conf)

    # Calculate and Display Pixel-to-MM Ratio
    if final_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
    else:
        st.write("No circles available for calculation.")




def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated circles.
    Ensures only valid and unique circles are retained.

    Args:
        updated_circles (list): Circles added or modified via the canvas.
        original_circles (list): Original detected circles.
        image_key (str): Unique key for identifying image-specific actions in Streamlit.

    Returns:
        list: Final combined list of circles (filtered and updated).
    """
    # Debug: Display original and updated circles
    st.write(f"Original Circles for {image_key}: {original_circles}")
    st.write(f"Updated Circles from Canvas for {image_key}: {updated_circles}")

    # Initialize filtered circles
    filtered_original_circles = original_circles[:]

    # Option to remove specific circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i + 1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )

        # Filter out the selected circles
        filtered_original_circles = [
            circle for i, circle in enumerate(original_circles) 
            if i not in selected_to_remove
        ]
        # Debug: Check filtered circles
        st.write(f"Filtered Original Circles (after removal): {filtered_original_circles}")
    else:
        st.write("No circles removed; using all detected circles.")

    # Combine filtered original circles with updated circles
    if updated_circles:  # Only combine if updated circles exist
        combined_circles = filtered_original_circles + updated_circles
    else:
        combined_circles = filtered_original_circles

    # Ensure unique circles (avoid duplicates)
    final_circles = list({tuple(circle) for circle in combined_circles})

    # Sort final circles (optional, based on x and y coordinates)
    final_circles = sorted(final_circles, key=lambda x: (x[0], x[1]))

    # Debug: Display final circles
    st.write(f"Final Circles for {image_key}: {final_circles}")

    return final_circles




def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated circles.
    Returns the final list of circles after filtering and combining.

    Args:
        updated_circles (list): Circles added or modified via the canvas.
        original_circles (list): Original detected circles.
        image_key (str): Unique key for identifying image-specific actions in Streamlit.

    Returns:
        list: Final combined list of circles (filtered and updated).
    """
    # Display the original and updated circles
    st.write(f"Original Circles for {image_key}: {original_circles}")
    st.write(f"Updated Circles from Canvas for {image_key}: {updated_circles}")

    # Option to remove specific circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i + 1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )

        # Filter out the selected circles
        filtered_original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
    else:
        # No removal; keep all original circles
        filtered_original_circles = original_circles

    # Combine the filtered original circles with updated circles
    combined_circles = filtered_original_circles + updated_circles

    # Ensure unique circles (no duplicates) using a set
    final_circles = list({tuple(circle) for circle in combined_circles})

    # Sort final circles for consistent order (optional, based on x-coordinate)
    final_circles = sorted(final_circles, key=lambda x: (x[0], x[1]))

    # Display the final combined circles for debugging
    st.write(f"Final Circles for {image_key}: {final_circles}")

    return final_circles




import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw circles on the image
def draw_circles(image_array, circles, color="blue"):
    """
    Draw circles (original, updated, or final) on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Interactive canvas for updating circles
def interactive_circle_editor(image_array, current_circles, image_key, max_width=400):
    """
    Canvas for displaying and editing circles interactively.
    """
    # Draw circles on the image
    image = draw_circles(image_array, current_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else current_circles

# Convert circles to DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Main application
with st.container():
    # File uploader stays at the top
    st.header("Upload data here:")
    file_uploaded = st.file_uploader(
        "Upload Images (PNG, JPG, JPEG)", 
        type=["png", "jpg", "jpeg"], 
        accept_multiple_files=True
    )

# Results container to display processed data
if file_uploaded:
    with st.container():
        # Dynamically adjust layout based on the number of uploaded images
        if len(file_uploaded) > 10:
            # Use a dropdown selector for more than 10 images
            image_selector = st.selectbox(
                "Select an Image to Process:",
                options=[(idx, file.name) for idx, file in enumerate(file_uploaded)],
                format_func=lambda x: f"Image {x[0] + 1}: {x[1]}",
            )
            selected_idx, selected_file = image_selector
            file_uploaded = [file_uploaded[selected_idx]]  # Only process the selected file

        # Process each image
        for idx, file in enumerate(file_uploaded):
            image_array = np.array(Image.open(file))
            detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

            # Display results
            st.title(f"Image {idx + 1}: {file.name}")

            # Three-column layout
            col1, col2, col3 = st.columns([2, 2, 1])

            # Original image with detected circles
            with col1:
                st.write(f"Original Image {idx + 1} with Detected Circles:")
                detected_image = draw_circles(image_array, detected_circles, color="red")
                st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

            # Editable canvas with updated circles
            with col2:
                st.write(f"Editable Canvas for Image {idx + 1}:")
                updated_circles = interactive_circle_editor(
                    image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
                )

                # Filter and combine circles
                st.write(f"Filter and Combine Circles for Image {idx + 1}:")
                final_circles = list(set(detected_circles + updated_circles))  # Avoid duplication

            # Results and DataFrames
            with col3:
                st.write(f"Circle Data in Table Format for Image {idx + 1}:")

                # Detected Circles Table
                detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
                st.write("Detected Circles:")
                st.dataframe(detected_df)

                # Updated Circles Table
                updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
                st.write("Updated Circles:")
                st.dataframe(updated_df)

                # Final Circles Table
                final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
                st.write("Final Circles:")
                st.dataframe(final_df)

                # Pixel-to-mm Ratio
                if final_circles:
                    pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                    st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
                else:
                    st.write("No circles available for calculation.")




import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw circles on the image
def draw_circles(image_array, circles, color="blue"):
    """
    Draw circles (original, updated, or final) on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Interactive canvas for updating circles
def interactive_circle_editor(image_array, current_circles, image_key, max_width=400):
    """
    Canvas for displaying and editing circles interactively.
    """
    # Draw circles on the image
    image = draw_circles(image_array, current_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else current_circles

# Function to filter and combine circles
def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them.
    """
    st.write(f"Original Circles for {image_key}:", original_circles)
    st.write(f"Updated Circles from Canvas for {image_key}:", updated_circles)

    # Option to remove specific circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write(f"Filtered Circles for {image_key}:", original_circles)

    # Combine filtered and updated circles
    return list(set(original_circles + updated_circles))

# Convert circles to DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Calculate pixel-to-mm ratio
def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
    """
    Calculate pixel-to-mm ratio based on circles.
    """
    if not circles:
        return None
    avg_diameter_px = np.mean([2 * r for _, _, r in circles])
    return known_diameter_mm / avg_diameter_px

# File uploader for multiple images
file_uploaded = st.file_uploader("Upload Images", type=["png", "jpg", "jpeg"], accept_multiple_files=True)

if file_uploaded:
    # Add tabs for each image
    tabs = st.tabs([f"Image {idx + 1}" for idx in range(len(file_uploaded))])

    for idx, (file, tab) in enumerate(zip(file_uploaded, tabs)):
        with tab:
            # Load the image
            image_array = np.array(Image.open(file))
            detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

            st.title(f"Image {idx + 1}")

            # Column layout
            col1, col2, col3 = st.columns([2, 2, 1])

            # Original image with detected circles
            with col1:
                st.write(f"Original Image {idx + 1} with Detected Circles:")
                detected_image = draw_circles(image_array, detected_circles, color="red")
                st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

            # Editable canvas with updated circles
            with col2:
                st.write(f"Editable Canvas for Image {idx + 1}:")
                updated_circles = interactive_circle_editor(
                    image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
                )

                # Filter and combine circles
                st.write(f"Filter and Combine Circles for Image {idx + 1}:")
                final_circles = filter_and_combine_circles(updated_circles, detected_circles, f"image_{idx}")

            # Results and DataFrames
            with col3:
                st.write(f"Circle Data in Table Format for Image {idx + 1}:")

                # Detected Circles Table
                detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
                st.write("Detected Circles:")
                st.dataframe(detected_df)

                # Updated Circles Table
                updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
                st.write("Updated Circles:")
                st.dataframe(updated_df)

                # Final Circles Table
                final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
                st.write("Final Circles:")
                st.dataframe(final_df)

                # Pixel-to-mm Ratio
                if final_circles:
                    pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                    st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
                else:
                    st.write("No circles available for calculation.")



import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw detected circles on the image
def draw_detected_circles(image_array, circles, color="red"):
    """
    Draw detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to draw final updated circles on the image
def draw_final_circles(image_array, circles, color="green"):
    """
    Draw updated or final circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to handle interactive circle updates
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Editable canvas that dynamically updates circles.
    """
    # Draw the detected circles on the image
    image = draw_detected_circles(image_array, detected_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else detected_circles

# Function to convert circles to a pandas DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Function to filter and combine circles
def filter_and_combine_circles(updated_circles, original_circles, image_key):
    """
    Allow users to remove unwanted circles and combine them with updated ones.
    """
    st.write(f"Original Circles for {image_key}:", original_circles)
    st.write(f"Updated Circles from Canvas for {image_key}:", updated_circles)

    # Option to remove specific detected circles
    if st.checkbox(f"Remove unwanted circles for {image_key}?", key=f"remove_checkbox_{image_key}"):
        selected_to_remove = st.multiselect(
            f"Select circles to remove for {image_key} (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
            key=f"remove_multiselect_{image_key}"
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write(f"Filtered Circles for {image_key}:", original_circles)

    # Combine filtered original circles and updated circles
    final_circles = original_circles + updated_circles
    return final_circles

# Placeholder function to calculate pixel-to-mm ratio
def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
    """
    Calculate pixel-to-mm ratio based on detected or updated circles.
    """
    if not circles:
        return None
    avg_diameter_px = np.mean([2 * r for _, _, r in circles])
    return known_diameter_mm / avg_diameter_px

# File uploader for multiple images
file_uploaded = st.file_uploader("Upload Images", type=["png", "jpg", "jpeg"], accept_multiple_files=True)

if file_uploaded:
    for idx, file in enumerate(file_uploaded):
        # Load the image (convert to NumPy array for example purposes)
        image_array = np.array(Image.open(file))
        detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

        st.title(f"Image {idx + 1}")

        # Three-column layout
        col1, col2, col3 = st.columns([2, 2, 1])

        # Original image with detected circles
        with col1:
            st.write(f"Original Image {idx + 1} with Detected Circles:")
            detected_image = draw_detected_circles(image_array, detected_circles, color="red")
            st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

        # Editable canvas with updated circles
        with col2:
            st.write(f"Editable Canvas for Image {idx + 1}:")
            updated_circles = interactive_circle_editor(
                image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
            )

            # Filter and combine circles
            st.write(f"Filter and Combine Circles for Image {idx + 1}:")
            final_circles = filter_and_combine_circles(updated_circles, detected_circles, f"image_{idx}")

        # Results and DataFrames
        with col3:
            st.write(f"Circle Data in Table Format for Image {idx + 1}:")

            # Detected Circles Table
            detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
            st.write("Detected Circles:")
            st.dataframe(detected_df)

            # Updated Circles Table
            updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
            st.write("Updated Circles:")
            st.dataframe(updated_df)

            # Final Circles Table
            final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
            st.write("Final Circles:")
            st.dataframe(final_df)

            # Pixel-to-mm Ratio
            if final_circles:
                pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
            else:
                st.write("No circles available for calculation.")





if len(file_uploaded) > 1:
    for idx, file in enumerate(file_uploaded):
        # Load the image and process it (replace with your actual image handling logic)
        image_array = ...  # Load your image here as a NumPy array
        detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

        st.title(f"Image {idx + 1}")

        # Three-column layout
        col1, col2, col3 = st.columns([2, 2, 1])

        # Original image with detected circles
        with col1:
            st.write(f"Original Image {idx + 1} with Detected Circles:")
            detected_image = draw_detected_circles(image_array, detected_circles, color="red")
            st.image(detected_image, caption=f"Detected Circles (Image {idx + 1})", use_column_width=True)

        # Editable canvas with updated circles
        with col2:
            st.write(f"Editable Canvas for Image {idx + 1}:")
            updated_circles = interactive_circle_editor(
                image_array, detected_circles, f"editable_canvas_{idx}", max_width=400
            )

            # Filter and combine circles
            st.write(f"Filter and Combine Circles for Image {idx + 1}:")
            final_circles = filter_and_combine_circles(updated_circles, detected_circles, f"image_{idx}")

        # Results and DataFrames
        with col3:
            st.write(f"Circle Data in Table Format for Image {idx + 1}:")

            # Detected Circles Table
            detected_df = circles_to_dataframe(detected_circles, label=f"Detected Circle (Image {idx + 1})")
            st.write("Detected Circles:")
            st.dataframe(detected_df)

            # Updated Circles Table
            updated_df = circles_to_dataframe(updated_circles, label=f"Updated Circle (Image {idx + 1})")
            st.write("Updated Circles:")
            st.dataframe(updated_df)

            # Final Circles Table
            final_df = circles_to_dataframe(final_circles, label=f"Final Circle (Image {idx + 1})")
            st.write("Final Circles:")
            st.dataframe(final_df)

            # Pixel-to-mm Ratio
            if final_circles:
                pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
                st.write(f"Pixel-to-MM Ratio for Image {idx + 1}: {pixel_to_mm_ratio:.4f}")
            else:
                st.write("No circles available for calculation.")




import streamlit as st
import pandas as pd
from PIL import Image, ImageDraw
from streamlit_drawable_canvas import st_canvas
import numpy as np

# Function to draw detected circles on the image
def draw_detected_circles(image_array, circles, color="red"):
    """
    Draw detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to draw final updated circles on the image
def draw_final_circles(image_array, circles, color="green"):
    """
    Draw updated or final circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline=color, width=2)
    return image

# Function to handle interactive circle updates
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Editable canvas that dynamically updates circles.
    """
    # Draw the detected circles on the image
    image = draw_detected_circles(image_array, detected_circles, color="blue")
    original_width, original_height = image.size

    # Scale the image to fit the canvas
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )

    # Process updated circles
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] / scale
                top = obj["top"] / scale
                width = obj["width"] / scale
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles if updated_circles else detected_circles

# Function to convert circles to a pandas DataFrame
def circles_to_dataframe(circles, label="Circle"):
    """
    Convert circle data to a pandas DataFrame.
    """
    return pd.DataFrame(
        circles,
        columns=["X Center", "Y Center", "Radius"],
        index=[f"{label} {i+1}" for i in range(len(circles))]
    )

# Placeholder function to calculate pixel-to-mm ratio
def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
    """
    Calculate pixel-to-mm ratio based on detected or updated circles.
    """
    if not circles:
        return None
    avg_diameter_px = np.mean([2 * r for _, _, r in circles])
    return known_diameter_mm / avg_diameter_px

# Placeholder image and circle data
image_array = np.ones((500, 500, 3), dtype=np.uint8) * 255  # Example white image
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example detected circles

# Streamlit layout
st.title("Interactive Circle Editor and Results")

# Three-column layout
col1, col2, col3 = st.columns([2, 2, 1])

# Original image with detected circles
with col1:
    st.write("Original Image with Detected Circles:")
    detected_image = draw_detected_circles(image_array, detected_circles, color="red")
    st.image(detected_image, caption="Detected Circles", use_column_width=True)

# Editable canvas with updated circles
with col2:
    st.write("Editable Canvas with Updated Circles:")
    updated_circles = interactive_circle_editor(
        image_array, detected_circles, "editable_canvas", max_width=400
    )

    # Optional: Show updated circles as a static image
    st.write("Updated Circles (Image):")
    updated_image = draw_final_circles(image_array, updated_circles, color="green")
    st.image(updated_image, caption="Updated Circles", use_column_width=True)

# Results and DataFrames
with col3:
    st.write("Circle Data in Table Format:")

    # Detected Circles Table
    detected_df = circles_to_dataframe(detected_circles, label="Detected Circle")
    st.write("Detected Circles:")
    st.dataframe(detected_df)

    # Updated Circles Table
    updated_df = circles_to_dataframe(updated_circles, label="Updated Circle")
    st.write("Updated Circles:")
    st.dataframe(updated_df)

    # Pixel-to-mm Ratio
    if updated_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(updated_circles)
        st.write(f"Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
    else:
        st.write("No circles available for calculation.")




from PIL import Image, ImageDraw
import numpy as np
import streamlit as st
from streamlit_drawable_canvas import st_canvas

# Function to draw the detected circles on the image
def draw_detected_circles(image_array, circles):
    """
    Draw the detected circles on the image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    for x, y, r in circles:
        draw.ellipse((x - r, y - r, x + r, y + r), outline="red", width=2)
    return image

# Interactive circle editor
def interactive_circle_editor(image_array, detected_circles, image_key, max_width=400):
    """
    Display the image with detected circles and allow interactive editing.
    """
    # Convert the image to a PIL Image
    image = draw_detected_circles(image_array, detected_circles)
    original_width, original_height = image.size

    # Calculate new display dimensions while preserving aspect ratio
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0  # No scaling needed

    # Scaling factors for converting between display and original dimensions
    scale_x = original_width / display_width
    scale_y = original_height / display_height

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",  # Fill for new circles
        stroke_width=2,
        stroke_color="blue",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )
    
    # Extract updated circles from canvas data
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] * scale_x
                top = obj["top"] * scale_y
                width = obj["width"] * scale_x
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles, scale

# Function to combine and filter circles
def filter_and_combine_circles(updated_circles, original_circles):
    """
    Allow users to remove unwanted original circles and combine them with updated ones.
    """
    st.write("Original Detected Circles:", original_circles)
    st.write("Updated Circles from Canvas:", updated_circles)

    # Option to remove specific detected circles
    if st.checkbox("Remove detected circles?"):
        selected_to_remove = st.multiselect(
            "Select detected circles to remove (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write("Filtered Original Circles:", original_circles)
    
    # Combine filtered original circles and updated circles
    final_circles = original_circles + updated_circles
    return final_circles

# Example integration in Streamlit
st.title("Interactive Circle Editor with Dynamic Pixel-to-MM Updates")

# Example image and circle data
image_array = ...  # Replace with your image as a NumPy array
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example original circles

# Layout with three columns
col1, col2, col3 = st.columns([2, 1, 1])  # Adjust width ratios as needed

with col1:
    st.write("Canvas with Detected Circles:")
    updated_circles, scale = interactive_circle_editor(image_array, detected_circles, "example_image", max_width=400)

with col2:
    st.write("Combine and Filter Circles:")
    final_circles = filter_and_combine_circles(updated_circles, detected_circles)

with col3:
    st.write("Pixel-to-MM Ratio and Results:")
    if final_circles:
        # Example function for pixel-to-mm ratio
        def calculate_pixel_to_mm_ratio(circles, known_diameter_mm=1.97):
            avg_diameter_px = np.mean([2 * r for _, _, r in circles])
            return known_diameter_mm / avg_diameter_px

        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Updated Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
        st.write("Final Circles Used for Calculation:")
        st.json(final_circles)
    else:
        st.write("No circles available for calculation.")








def interactive_circle_editor(image_array, detected_circles, image_key, max_width=300):
    """
    Display the image in a canvas within a column without distortion and allow circle editing.
    """
    from PIL import Image, ImageDraw

    # Convert the image to a PIL Image
    image = Image.fromarray(image_array)
    original_width, original_height = image.size
    
    # Calculate new display dimensions while preserving aspect ratio
    if original_width > max_width:
        scale = max_width / original_width
        display_width = max_width
        display_height = int(original_height * scale)
    else:
        display_width = original_width
        display_height = original_height
        scale = 1.0  # No scaling needed

    # Scaling factors for converting between display and original dimensions
    scale_x = original_width / display_width
    scale_y = original_height / display_height

    # Streamlit canvas for editing
    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.3)",  # Fill for new circles
        stroke_width=2,
        stroke_color="red",
        background_image=image.resize((display_width, display_height)),
        height=display_height,
        width=display_width,
        drawing_mode="circle",
        update_streamlit=True,
        key=f"canvas_{image_key}",
    )
    
    # Extract updated circles from canvas data
    updated_circles = []
    if canvas_result.json_data is not None:
        objects = canvas_result.json_data.get("objects", [])
        for obj in objects:
            if obj["type"] == "circle":
                # Adjust for scaling
                left = obj["left"] * scale_x
                top = obj["top"] * scale_y
                width = obj["width"] * scale_x
                radius = width / 2
                x_center = left + radius
                y_center = top + radius
                updated_circles.append((x_center, y_center, radius))

    return updated_circles, scale

def filter_circles(updated_circles, original_circles):
    """
    Allow users to deselect or remove unwanted original circles.
    """
    st.write("Original Circles:", original_circles)
    st.write("Updated Circles:", updated_circles)

    # Example: Remove a specific circle
    if st.checkbox("Remove unwanted circles?"):
        selected_to_remove = st.multiselect(
            "Select circles to remove (index-based):",
            options=list(range(len(original_circles))),
            format_func=lambda i: f"Circle {i+1}: {original_circles[i]}",
        )
        # Filter out the selected circles
        original_circles = [
            circle for i, circle in enumerate(original_circles) if i not in selected_to_remove
        ]
        st.write("Filtered Circles:", original_circles)
    
    # Combine updated and remaining original circles
    final_circles = original_circles + updated_circles
    return final_circles

# Example integration in a three-column layout
st.title("Interactive Circle Editor with Three Columns")

# Example image and circle data
image_array = ...  # Replace with your image as a NumPy array
detected_circles = [(100, 150, 30), (200, 300, 50)]  # Example original circles

# Three-column layout
col1, col2, col3 = st.columns([2, 1, 1])  # Adjust width ratios as needed

with col1:
    st.write("Canvas for Editing Circles:")
    updated_circles, scale = interactive_circle_editor(image_array, detected_circles, "example_image", max_width=300)

with col2:
    st.write("Circle Data:")
    final_circles = filter_circles(updated_circles, detected_circles)

with col3:
    st.write("Pixel-to-MM Ratio and Results:")
    if final_circles:
        pixel_to_mm_ratio = calculate_pixel_to_mm_ratio(final_circles)
        st.write(f"Updated Pixel-to-MM Ratio: {pixel_to_mm_ratio:.4f}")
        st.write("Final Circles Used:")
        st.json(final_circles)
    else:
        st.write("No circles to calculate.")